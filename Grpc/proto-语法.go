

---------------------------------
语法
---------------------------------
	# 版本声明
		edition = "2023";
		syntax="proto2";
		syntax="proto2"
		
		* 版本声明必须是文件中第一行非空、非注释的内容。
		* 如果没有指定版本或语法，编译器将假定默认使用的是 proto2
	
	# 字段编号
		
		* 必须为每个字段定义编号(1 - 536,870,911)，且不能重复
			int64 id = 1;
		
		* 19,000 - 19,999 是保留实现，如果被使用了则编译器会给出警告
		* 一旦给字段定义了编号后，就不能更改了，更改字段编号相当于删除该字段，并创建一个类型相同但编号不同的新字段。
		* 较低的字段编号值在传输格式中占用的空间较少，1 到 15 范围内的字段编号占用一个字节进行编码。16 到 2047 范围内的字段编号占用两个字节。
		* 字段号如果被重复使用的话，会导致出现很多问题
	

	# 字段数量
		* 就是这个字段可以出现多少次
			repeated int64  id = 1 ;
		
			repeated(废弃)
				* 字段必须存在，且只能出现一次。
			
			optional(proto3 默认)
				* 字段可选，既可以提供也可以不提供。
			
			repeated
				* 字段可以出现多次，通常用于表示一个数组或列表。

		* 在 2023 版本中，不需要明确指定 optional 或 required。
		* 如果有值，则解析/写入。
		* 如果没显式设置，其值默认为默认值（如数字为 0，字符串为空，布尔值为 false 等），不会被序列化到数据流中。
		
	
	# 保留字段
		* 通过 reserved 关键字定义保留字段名称或者是编号（不能混用）
			
			// 保留 ID，支持用 to 语法，选择一个区间
			reserved 2, 15, 9 to 11; 
			// 保留字段名称
			reserved foo, bar;
		
		* 被声明为保留字段名称、编号的名称、编号不能在 message 中定义，否则编译器异常。
		* 保留名仅影响协议编译器的行为，而不影响运行时的行为。

	
	# 默认值
		
		* 通过 default 关键字设置默认值
			 int64  parentMemberId = 1 [default = -1];

		* 只能给基础的标量类型设置
		* 如果没设置值，就会使用默认值，且生成的模型 api hasXxx 方法会返回 false，表示未设置该字段。但是 getXxx 会返回默认值。
	

	# 枚举
		* 通过 enum 定义枚举，值只能是数值（32 位）且不能重复
			// 定义颜色枚举
			enum Color {
			  read = 0;
			  black = 1;
			  blue = 2;
			}

			message Member {
			  int64  id = 1;
			  Color color = 2;
			  Color defaultColor = 3 [default = read];
			}
		
		* 枚举的第一个项目值必须是 0
		* 值虽然可以是负数但是不建议（效率低），
		
		* 通过 allow_alias 属性开启枚举别名，即可以给相同值的枚举定义不同的名称
			enum Color {

			  // 开启允许别名
			  option allow_alias = true;
			  red = 0;

			  blue = 2;
			  // blue 和 skuBlue 的值一样，相互别名
			  skuBlue = 2;
			}
		
		
		
		* 在序列化/反序列化的时候，未识别的非法枚举值会被保留（本质上就是数值），但是具体要看不同语言的处理方式。
			* 对于 go 来说，枚举本质上就是 int，所以会原样保留非法的枚举值
			* 对于 Java，会被映射为一个特殊的 “未识别” 值，通常是一个名为 UNRECOGNIZED 的枚举常量。


	
	
	# 嵌套定义
		
		* 可以无限的在 message 中嵌套 message 定义，并且可以导航访问到

			message Member {
			  // 嵌套在 Member 中的枚举
			  enum Role {
				Member = 0;
				Manager = 1;
			  }

			  int64  id = 1;
			  Role role = 2;
			}

			message MemberDetail {
			  int64  id = 1;

			  // 通过嵌套访问，定义枚举类型
			  Member.Role role = 2;
			}
		

	
	# 未知的字段
		
		* protobuf 反序列化的时候，未知字段的数据会被保留。
		* 未知字段的产生，可能是因为在不同的 pb 版本之间反序列化导致的（新的版本没这个字段了，仍然可以解析旧版本有这个字段的 pb 二进制数据）。
		* 尽量不要让这种未知字段丢失了，所以在进行传输的时候，还是要用 pb 的序列化方法来进行序列化后传输。
	

