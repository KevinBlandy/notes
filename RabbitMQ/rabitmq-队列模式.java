---------------------
队列模式
---------------------
	# 6种模式
		1,HelloWord
		2,Work Queues
		3,Publish/Subscribe
		4,Routing
		5,Topics
		6,Publish Confirms

	# 普通,work,订阅,路由,通配符
	
	# 严格来说RabbitMQ只有三种模式
		1,(直连模式)点对点.最简单.生产者把消息发给队列,消费从队里消费消息.'一条消息,最终只能被一个消费者消费'

		2,(work模式)点对多.生产者把消息发给队列.N个消费者从队列里面消费消息.'一条消息,最终只能被一个消费者消费'
			* 消费者消费情况又可以分为两种
				1,雨露匀沾,消息你一条我一条.不乱
				2,能者多劳,谁消费快,谁就消费多

		3,(订阅模式)点对多.生产者把消息发送给'交换机',N个消费者自己创建队列来绑定交换机.'一条消息,可以被N个消费者消费'
			* 如果生产者把消息发送给了未绑定队列的交换机,那么该消息将会丢失
		
	# 剩下的两种,纯粹就是交换机的不同而已
		4,(路由模式)点对多,生产者产生消息.并且给消息绑定一个'路由key',推送到交换机.消费者自己创建N个队列,绑定'路由key',绑定到交换机.交换机收到消息后.就会根据'路由key',把消息推送到相同的消费队列里面
		5,(通配模式)点对多,跟上面其实一样,区别在于'上面是key必须一样,就推送消息,而这个,只要是符合匹配规则就OK'
			* 通配符有两种
				1,#
					一个或者多个词儿
				2,*
					只能是一个词儿
		
		6,RPC...不适合，RPC还是用其他的框架代替


	
	# 三种交换机
		1,(订阅模式)点对多,说白了.消息到路由.哪个消费者把队列绑定到了路由都可以收到
		2,(路由模式)点对多,消息是绑定了一个key,消费者把队列绑定路由时也要设置key,这样就保证了不同的消息,到不同的路由去
		3,(通配模式)点对多,跟上面一样,不同的是,这个可以通过匹配符号,来匹配到消息

	
	# 完成交换机和队列的绑定,有两种方式
		1,在程序(或者spring配置)中完成
		2,在MQ后台管理中完成
			* 实际的开发中都是通过后台管理,人工的进行分配.这样耦合度最低


---------------------
交换机
---------------------
	# direct(路由模式)
		* 把消息路由到那些 BindingKey 和 RoutingKey完全匹配的队列中
		* 生产者和消费者的消息KEY必须一样

	# fanout(订阅模式)
		* 把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中

	# topic(通配模式)
		* 它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，支持表达式模糊匹配
		* 首先，key的定义是: 以'.'分割的字符串，每一个独立的子串儿就被称之为一个词儿
			io.springboot				// 2个词儿
			io.springboot.order			// 3个词儿
			io.springboot.queue.sms		// 4个词儿

		* 通配符有两种
			1,#
				一个或者多个词儿
			2,*
				只能是一个词儿
			
		* 一些表达式
			"io.springboot.*"		// 仅仅匹配一个词儿
			"io.springboot.#"		// 匹配所有词儿


	# headers
		* 根据header值来匹配的，性能贼差，基本不用
	