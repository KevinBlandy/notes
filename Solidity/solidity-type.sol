-------------------------
数据类型
-------------------------

	# 静态语言，变量需要指定类型
		
		* 变量没有 undefined\null，每种变量都有默认值
	
-------------------------
bool
-------------------------
	# 布尔值，固定常量 true/false

	# 支持逻辑运算
		!
		||
		&&
		==
		!=

		* || 和 && 是短路运算
	


-------------------------
integer
-------------------------
	# 按照有无符号分为两类

		uint	// 无符号类型
		int		// 有符号类型
	
	# 大小以 8 为步长

		int8
		int16
		int32
		int64
		int128
		int256

		uint8
		uint16
		uint32
		uint64
		uint128
		uint256

		* uint 和 int 分别是 uint256 和 int256 的别名。
	
	# 获取最小和大值
		type(x).min // 变量 x 的最小值
		type(x).max // 变量 x 的最大值
	
	# 比较运算
		* <=、<、==、!=、>=、>

	# 位移运算
		* &、|、^、~

		* 右操作数必须是无符号类型，否则异常。
		* 不会检查溢出
	
	# 算数运算
		* +、-、*、/、%、**

		* 溢出会被截断
		* 除法始终会产生一个整数，向零舍入。
		* 注意：字面量上的除法会产生任意精度的分数值。
	
	# 指数运算
		
		* 使用 ** 符号
		* 仅适用于无符号类型，运算的结果类型始终等于基数的类型
		

-------------------------
定长浮点型
-------------------------
	
	# Solidity 中尚未完全支持定长浮点型
		* 可以被声明，但不能被赋值。
	
	# 有符号和无符号
	
		ufixedMxN
		fixedMxN
		
		* M 表示类型占用的位数，必须是 8 的倍数，范围从 8 到 256 位。
		* N 表示可用的小数位数，必须在 0 到 80 之间（包括 0 和 80）。
		
		ufixed
			* ufixed128x18 的别名
		fixed
			* fixed128x18 的别名

-------------------------
有理数和整数字面量
-------------------------
	# 支持一般的十进制和十六进制
		778
		0xFF
		
		* 不支持八进制，前导 0 是无效的

	# 支持十进制分数字面量
		.1		// 小数点前省略整数部分，相当于 0.1
		1.3		// 常见的十进制数
		0.0005	// 合法
		123.456	// 合法
	
	# 支持科学计数法

		1e3     // 1000
		2.5e-3  // 0.0025 尾数部分可以是小数
		.1e2    // 10
	
	# 支持使用下划线分隔符以提高可读性
		
		123_000
		0x2eff_abde
		1_2e345_678 
	
	# 字面量类型
	
		* 数字字面量没有固定类型，而是根据上下文推导类型。
		
		* 数字字面量表达式在转换为非字面量类型之前保持任意精度。
			
			// 字面量表达式
			// 只包含编译期可确定的常量数字，没运行时值，所以可以由编译器在编译阶段完全计算出来
			
			1 + 2
			(2**800 + 1) - 2**800	// 值远远超过 256 位整数的上限，但编译器在常量求值阶段仍然能正确计算
			.5 * 8					// 编译器看到结果是整数，就会推导为整数类型。
			
			* 不受机器字长（例如 uint256）限制；
			* 不会产生溢出（overflow）；
			* 编译器的常量求值是数学意义上的精确运算，不会像整数除法那样截断。（truncation）。
		
			* 注意，有某些运算符不遵循此模式（它们是在类型 uint8 内计算的，并且可能会溢出）
			
				三元运算符：255 + (true ? 1 : 0) // true ? 1 : 0 的类型会被推断为 uint8（默认整数类型）
				数组下标：255 + [1, 2, 3][0]	// [1, 2, 3] 是一个 uint8[] 类型的数组（默认）

	# 表达式

		* 整数能用的运算符，表达式都可以用
		
		* 如果表达式中其中任何一个是分数，则不允许位运算；如果指数是分数，则不允许指数运算。
		* 位运算（&, |, ^, ~, <<, >>）要求操作数必须是整数。
		
		* 使用字面量数字作为左侧（基数）操作数和整数类型作为右侧（指数）操作数的移位和指数运算始终在 uint256 或 int256 类型中执行。
			
			// 不管 shift 的类型是不是 uint8，编译器都自动在 uint256 / int256 范围内计算移位。

			uint8 shift = 3;
			uint256 x = 2 << shift;   // 左边是字面量 2，类型为 uint256
			int256  y = -2 << shift;  // 左边是负字面量，类型为 int256
		
		* 数字字面量表达式与已确定类型的表达式混合使用时：
			
			* 会被转换为非字面量类型，但这种转换并非总是可行。
			* 编译器会尝试找出一个共同类型（common type），如果找不到共同类型，就编译错误。

-------------------------
定长字节数组
-------------------------
	
	# 从 bytes1 到 bytes32
		* 从 1 到 32 字节
	
	# 运算符
		* 支持大小比较
		* 支持位运算
		* 支持位移
	
	# 索引访问
		* 支持索引 [i] 访问第N个字节，只读
		* 如果索引是常量并且越界，编译器会报错；索引是变量时，务必在代码逻辑中保证范围正确。
		* 可与数值类型互相转换（需要显式转换），例如 uint8(x[i]) 可以把字节变成对应的整数 0–255。
	
	# 注意当字节数组时的存储问题
		* bytes1[] 是字节数组，但 bytes1 虽然逻辑上只有 1 字节，但在 memory/calldata 中每个元素都会被填充（padded）成 32 字节，最好使用 bytes 类型。
		* memory 和 calldata 中的数组（比如bytes1[]）的每个元素都要占据32字节的倍数。不足32字节的，会自动 padding 到32字节

		* storage 中除外，因为 在 storage 里，bytes1[] 和 bytes 在空间效率上几乎一样（Solidity 压缩规则，编译器在存储布局上会自动压缩相邻的字节）。

	# 属性
		
		length
			* 返回字节数组的长度

-----------------------------------------
enum
-----------------------------------------
	# 使用 enum 关键字声明枚举
		enum Color {
			RED, BLUE, WHITE, BLACK
		}
			
		
		* 每个枚举成员的值从 0 开始递增
		* 第一个值是默认值，且起码要有一个值，成员不能超过 256 个
		* 可以和整数类型进行转换，但是需要显示转换，如果转换的整数大于了枚举的表示值，则异常。
			
			// enum -> uint8
			uint8 redVal = uint8(Color.RED); 
			// uint8 -> enum
			Color red = Color(0);

		* 使用 type(Color).min 和 type(Color).max 可以获取给定枚举的最小值和最大值。
			
			Color max = type(Color).max;
			Color min = type(Color).min;
	
	# 合约不是 ABI 的一部分，函数参数中的枚举会被编译为 uint8

		// 签名将自动更改为 "maxColor() returns (uint8)"。
		function maxColor() public pure returns(Color){
			return type(Color).max;
		}
	
	# 枚举也可以在文件级别声明，位于合约或库定义之外


-------------------------------
别名
-------------------------------
	# 把已存在的类型声明为另一种类型
		
		type C is V

		* C 是新的类型名称
		* V 必须是内置类型（基础类型）
	
		* C.warp() 把基础类型封装为自定义类型
		* C.unwrap() 把自定义类型转换为基础类型


		type ID is uint;

		ID nextId = ID.wrap(100000000);
		uint idVal = ID.unwrap(nextId);
	
	# 限制
		
		* 没有运算符或附加成员函数（不能重载运算符，也不能添加额外的方法）
		* 自定义类型之间以及与其他类型之间的显式和隐式转换是不允许的。
		* 没有运算符 == 或 !=
			
