--------------------------
定位
--------------------------
	# position 属性的初始值是: static
		* 如果把它改成其他值, 就可以说元素就被定位了(定位元素)
		* 如果是默认值（静态定位）, 那么就可以说元素未被定位（无定位）
	
	# 定位
		* 由两部分组成：定位模式 + 边偏移
		* 定位模式：元素在文档中的定位方式
		* 边偏移：元素的最终位置
	
	# 边偏移，只有四个属性
		* top: 顶端偏移量，定义元素相当于其父元素上边线的距离
		* bottom: 底部偏移量。。。下边线的距离
		* left: 左侧偏移量。。。左边线的距离
		* right: 右侧偏移量。。。右边线的距离
	
	
	# 注意
		1. 行内元素添加绝对定位和固定定位，可以直接设置宽度和高度
		2. 块级元素添加定位后，如果不设置宽高，则默认为内容的宽高
		3. 不会发生外边距合并
		4. 绝对定位会完全压住盒子，包括盒子中的文字和图片
		5. 如果有定位的盒子，慎用 overflow: hidden; 因为它可能会隐藏超出盒子的部分

--------------------------
固定定位
--------------------------
	# position: fixed
		* 能将元素放在视口（可视区）的任意位置

		* 这需要搭配四种属性一起使用: top, right, bottom, left
		* 这些属性的值决定了固定定位的元素与浏览器视口边缘的距离

		* 设置这四个值还隐式地定义了元素的宽高
			* 比如指定 left: 2em; right: 2em 表示元素的左边缘距离视口左边2em, 右边缘距离视口右边2em
			* 因此元素的宽度等于视口总宽度减去4em, top, bottom和视口高度也是这样的关系
		
		* 脱离文档流，不占用空间
		* 不会随着滚动条滚动
	
	# 控制定位元素的大小
		* 定位一个元素时, 不要求指定四个方向的值, 可以只指定需要的方向值, 然后用width和/或height来决定它的大小
		* 也可以让元素本身来决定大小
			position: fixed;
			top: 1em;
			right: 1em;
			width: 20%
			/* 元素放在距离视口顶部和右边1em的位置，宽度为视口宽度的20% */
			/* 它省略了bottom和height属性，元素的高度由自身的内容决定 */
	
	# 紧贴中间栏的实现
		
	

--------------------------
绝对定位
--------------------------	
	# position: absolute
	# 固定定位的包含块是视口, 而绝对定位的包含块是：'相对最近的祖先定位（哪种定位都行）元素'
		* 跟固定元素一样, 属性 top, right, bottom, left 决定了元素的边缘在包含块里的位置

		* 如果父元素未被定位, 那么浏览器会沿着 DOM 树往上找它的祖父, 曾祖父, 直到找到一个定位元素, 用它作为包含块.
		* 如果祖先元素都没有定位, 那么绝对定位的元素会基于初始包含块（initial containing block）来定位, 初始包含块跟视口一样大, 固定在网页的顶部.
	
	# 绝对定位会脱离文档流，后面的元素会占用元素空间。

	# 通常：子元素用绝对定位，父级用相对定位
		* 子元素绝对定位，不会占用文档流，可以放置在父元素的任意位置，而不会响应其他兄弟元素。
		* 父元素，用相对定位，不会脱离文档，保留位置。
	
	# 类似于特殊的固定定位

--------------------------
相对定位
--------------------------
	# position: relative
	# 以自己原来的位置为准，进行定位
	# 跟固定或者绝对定位不一样, 不能用 top、right、bottom 和 left 改变相对定位元素的大小
		* 这些值只能让元素在上, 下, 左, 右方向移动
		* 可以用 top 或者 bottom, 但它们不能一起用(bottom 会被忽略)
		* 可以用 left 或 right, 但它们也不能一起用(right 会被忽略)
	
		* 也可以使用负值，比如 bottom: -1em，就会像 top: 1em 那样将元素向下移动 1em

	
	# 定位后，元素的原位置会保留在文档流中，继续占有。后面的盒子仍以标准流的形式对待它
	# 它最典型的作用就是给 “绝对定位” 当容器（爹）的。

--------------------------
粘性定位
--------------------------
	# position: sticky;
	# sticky 定位，相对和固定定位的混合
		* 以浏览器的可视窗口为参照物移动元素（固定定位特点）
		* 占有文档流的位置（相对定位的特点）
		* 必须添加 top、right、bottom、left 其中一个属性才会生效。
		
		* Safari可能需要添加前缀: position: -webkit-sticky
	
		* 正常情况下, 元素会随着页面滚动, 当到达屏幕的特定位置时, 如果用户继续滚动, 它就会"固定"在这个位置（最常见的用例是侧边栏导航）
	
	# 和页面滚动配合使用，IE 貌似不支持
		<body>
			<div class="menu"></div>
		</body>

		body {
			height: 3000px;	/*足够长的长度，产生滚动条*/
		}
		.menu {
			position: sticky;  /*粘性定位*/
			top: 1px;			/*定位距离可视窗口上边 1px*/
			width: 500px;
			height: 150px;
			background-color: skyblue;
			margin: 150px auto; /*距离上边 150px*/
		}

		* 当往下滚动，.menu 元素距离可视窗口上边只有 1px 的时候，粘性定位生效。元素会固定在顶部 1px的位置。不会随着滚动条滚动。

--------------------------
层叠上下文 & zindex
--------------------------
	# 渲染过程和层叠顺序
		* 浏览器将HTML解析为DOM的同时还创建了另一个树形结构, 叫作渲染树(render tree)
		* 它代表了每个元素的视觉样式和位置, 同时还决定浏览器绘制元素的顺序
		* 顺序很重要, 因为如果元素刚好重叠(例如使用负外边距), '后绘制的元素就会出现在先绘制的元素前面'

	
	# 只有定位元素，才有这个属性

	# 使用定位之前(通常情况)
		* 元素在HTML里出现的顺序决定了绘制的顺序
	
	# 使用定位
		* 使用定位元素时, 这种行为会改变
		* 浏览器会先绘制所有非定位的元素, 然后绘制定位元素, 默认情况下, 所有的定位元素会出现在非定位元素前面
		
		* 多个定位元素之间, 还是遵循基于源码的层叠的关系, 后来居上
	
	# z-index: 控制层叠顺序
		* 固定定位元素放在HTML中哪里都合适(标记位置一般是在</body>之前)

		* 相对定位或绝对定位的元素, 通常无法用改变标记位置的方法解决层叠问题
		* 相对定位依赖于文档流, 绝对定位元素依赖于它的定位祖先节点

		* z-index属性值可以是正数, 负数
		* 较高index的元素会在较低index值元素的前面, 负index值的元素出现在静态元素后面
	
	
	# 层叠上下文
		* 一个'层叠上下文包'含'一个元素'或者由浏览器一起绘制的'一组元素'
		* 给一个定位元素加上z-index的时候, 它就变成了一个新的层叠上下文的根, 所有后代元素就是这个层叠上下文的一部分

		* 如果一个元素叠放在一个层叠上下文前面, 那么层叠上下文里没有元素可以被拉到该元素前面(层叠上下文之外的元素无法叠放在层叠上下文内的两个元素之间)
		* 同理, 如果一个元素被放在层叠上下文后面, 层叠上下文里没有元素能出现在该元素后面

		* 所有层叠上下文内的元素会按照以下顺序, 从后到前叠放:
			* 层叠上下文的根
			* z-index为负的定位元素(及其子元素)
			* 非定位元素
			* z-index为auto的定位元素(及其子元素)
			* z-index为正的定位元素(及其子元素)
		


