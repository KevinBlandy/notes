--------------------------
CopyOnWriteArrayList		|
--------------------------
	# 适合'安全的并发迭代'操作的应用场景
		* 添加操作多的时候,效率低
		
	# 写入并复制
		* 每次写入数据的时候,都会在低层复制出新的一个列表,再进行添加
		* 在 CopyOnWriteArrayList 中，读不需要锁，可以并行，读和写也可以并行，但多个线程不能同时写，每个写操作都需要先获取锁。

	
	# 它要处理的问题
		* Java的list在遍历时,若中途有别的线程对list容器进行修改,则会抛出 ConcurrentModificationException 异常
		* 而 CopyOnWriteArrayList 由于其"读写分离"的思想,遍历和修改操作分别作用在不同的list容器
		* 所以在使用迭代器进行遍历时候,也就不会抛出 ConcurrentModificationException 异常了

		* 一句话,它就是为了解决在高并发下,执行修改不会抛出异常

	# 它带来的问题
		* 一是内存占用问题,毕竟每次执行写操作都要将原容器拷贝一份,数据量大时,对内存压力较大,可能会引起频繁GC
		* 二是无法保证实时性,Vector对于读写操作均加锁同步,可以保证读和写的强一致性
		* 而 CopyOnWriteArrayList 由于其实现策略的原因,写和读分别作用在新老不同容器上,在写操作执行过程中,读不会阻塞但读取到的却是老容器的数据
