			

------------------------
JAVA位移运算			|
-----------------------
	# 所谓的位运算,其实就是直接对二进制(位)进行计算
	# 运算最快的方式,其实就是位移运算
	# 在 BigInteger 类中都可以找到这些位移操作快捷的方法

		-------------------------------------------------------------------------------------------
									位运算
		-------------------------------------------------------------------------------------------
		运算符		|	运算		|BigInteger 方法	|	范例
		-------------------------------------------------------------------------------------------
		<<			|	左移		|shiftLeft(int n);	|3 << 2 = 12	-->		3 * 2 = 12
		-------------------------------------------------------------------------------------------
		>>			|	右移		|shiftRight(int n);	|3 >> 1 = 1		-->		3 / 2 = 1
		-------------------------------------------------------------------------------------------
		>>>			|	无符号右移	|					|3 >>> 1 = 1	-->		3 / 2 = 1
		-------------------------------------------------------------------------------------------
		&			|	与运算		|and(Integer num);	|6 & 3 = 2
		-------------------------------------------------------------------------------------------
		|			|	或运算		|or(Integer num);	|6 | 3 = 7
		-------------------------------------------------------------------------------------------
		^			|	异或运算	|xor(BigInteger num);|6 ^ 3 = 5
		-------------------------------------------------------------------------------------------
		~			|	反码		|not();				|~6 = -7
		-------------------------------------------------------------------------------------------

	<<
		# 相当于乘与2的倍数
		# 移动N位,就是乘以2的n次幂
		# 先把数据转换为2进制,然后向着左边移动N个位置,右边空出来的补0
		# 越移越大
		# shiftLeft(int n);

	>>
		# 相当于除以2的倍数
		# 移动N位,就是除以2的n次幂
		# 有符号右移，向右移动，右边的舍弃掉，左边补什么取决于原来最高位是什么，原来是 1 就补 1，原来是 0 就补 0，将二进制看作整数，右移1位相当于除以2。
		# 越移越小
		# shiftRight(int n);

	>>>	
		# 右移的时候,不管你的二进制最高位是几,一律补0
	
	&
		# 6 & 3
		# 其就是把俩数据都换算为2进制
		# 0 代表 false,1 代表 true
		# 剩下就是就是 true & false,挨个比
		# true & true = true;		1 & 1 = 1
		# false & false = false;	0 & 0 = 0
		# false & true = false;		0 & 1 = 0;
		# 通俗,俩位对比,必须都是1,结果就是1
		# Demo
			110		
		  & 011
		  -----
		    010
		# and(Integer num);
	|
		# 6 | 3
		# 也是把俩数据都换算为2进制
		# 0 代表 false,1 代表 true
		# 剩下就是就是 true | false,挨个比
		# true | true = true;		1 | 1 = 1
		# false | false = false;	0 | 0 = 0
		# false | true = false;		0 | 1 = 1;
		# 通俗,俩位对比,只要有一位是1,结果就是1
		# Demo
			110
		  | 011
		  -----
		    111
		# or(Integer num);
	
	^
		# 6 ^ 3
		# 把俩数都换算为2进制
		# 挨个比较,如果两边都相同,则是假也就是 0,两边不同则是真 1
		# Demo
			110
		  ^ 011
		  -----
		    101
		# 一个值异或一次n,再异或一次n!那么结果还是该值
		# 7 ^ 2 = '结果'
		# '结果' ^ 2 = 7;
		# 这就是传说中的加密
		# 这个抑或的值,其实就是传说中的'密钥';
		# xor(BigInteger num);

	~
		# 其实就是取反,懒得解释了
		# Demo
		 0000-0000 0000-0000 0000-0000 0000-0110	
		~---------------------------------------
		 1111-1111 1111-1111 1111-1111 1111-1001	
		# not();



	# 一个数的二进制负数表现形式为:该数据正数的二进制取反 + 1
	# 最有效率的写出 2 * 8 的计算方式
		* 左移运算
		* 2<<3
		* 2 的三次方就是 8

	# 对俩整数变量值进行互换,不用第三方变量
		int n = 3;
		int m = 8;

		n = n ^ m;
		m = n ^ m;
		n = n ^ m;

-----------------------
二进制与补码
-----------------------
	# 二进制使用最高位表示符号位，用 1 表示负数，用 0 表示正数
	# 只有负数才会用补码表示法，'负数的二进制表示就是对应的正数的补码表示。'
	# 补码即：原码取反 + 1
	# 以 byte 为例
		-1
			* 正数：1
			* 原码：00000001
			* 取反：11111110
			* 加一:	00000001
			* 补码：11111111
		
		-127
			* 正数：127
			* 原码：01111111
			* 取反：10000000
			* 加一：00000001
			* 补码：10000001
		
	
	# 给定一个负数的二进制表示，要想知道它的十进制值，可以采用相同的补码运算
		
		10010010
			* 已知是 1 开头，表示的值是一个负数
			* 取反：01101101
			* 加一：00000001
			* 结果：01101110
		
		01101110 十进制值为: 110, 所以原值就是 -110
	

		* 对负数的补码表示做补码运算就可以得到其对应正数的原码，正如十进制运算中负负得正一样。
		* 原因是，只有这种形式，计算机才能实现正确的加减法。计算机其实只能做加法，1 - 1 其实是1+(-1)
		
		* 1-1 其实是 1 + (-1)。如果用原码表示:
			 1    00000001
			-1    10000001
			+ ------------------
			-2    10000010
		
		* 负数以补码性质，正确
			 1	00000001
			-1	11111111				// 
			+ ------------------
			0	00000000
	
	# 例如：计算 3 - 5
		3
			* 原码：00000011
		
		+

		(-5)
			* 原码：00000101
			* 取反：11111010
			* 加一：11111011
		
		=
			00000011
			11111011
			--------
			11111110
		
		* 最高位是：1 ，表示结果是负数
		* 取反：00000001
		* 加一：00000010
		* 结果为 2，由于是负数，则结果为 -2

-----------------------
小数
-----------------------	
	# “小数” 是在数学中用的词，在计算机中，一般说的是“浮点数”。
		* float 和 double 被称为浮点数据类型，小数运算被称为浮点运算。
		* 为什么要叫浮点数呢？这是由于小数的二进制表示中，表示那个小数点的时候，点不是固定的，而是 '浮动' 的。
	
		* 比如 123.45 这个数值，十进制直接这么写，就是固定表示法，如果用科学记数法，在小数点前 '只保留一位数字'，可以写为 1.2345E2 即 1.2345 x (10^2)
		* 即在科学记数法中，小数点向左浮动了两位。
	
	# 二进制中为表示小数，也采用类似的科学表示法，如 m x (2^e)。m 称为尾数，e 称为指数。
		* 指数可以为正，也可以为负，负的指数表示那些接近0的比较小的数。在二进制中，单独表示尾数部分和指数部分，另外还有一个符号位表示正负。

		* 32位格式中，1位表示符号，23位表示尾数，8位表示指数。
		* 64位格式中，1位表示符号，52位表示尾数，11位表示指数。
	

