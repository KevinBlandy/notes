------------------------
redis-stream			|
------------------------
	# 文档
		https://docs.spring.io/spring-data/redis/docs/current/reference/html/#redis.streams
	
	# 一定要熟悉redis的stream机制, 熟悉了之后, 对于api来说, 只是找到对应的方法就是了

------------------------
redis-stream 发布数据	|
------------------------
	# 通过静态类 StreamRecords 创建 stream 的记录
		ByteRecord rawBytes(Map<byte[], byte[]> raw)
		ByteBufferRecord rawBuffer(Map<ByteBuffer, ByteBuffer> raw)
		StringRecord string(Map<String, String> raw)
			
		<S, K, V> MapRecord<S, K, V> mapBacked(Map<K, V> map)
		<S, V> ObjectRecord<S, V> objectBacked(V value)
		RecordBuilder<?> newRecord()
	
	# 也可以通过内部的builder类创建 stream 的记录

	# 通过 Connection 写入到stream
		public class RedisStreamTest {
	
			@Autowired
			private RedisConnectionFactory redisConnectionFactory;
			
			public void test () {
				// 创建消息记录, 以及指定stream
				ByteRecord byteRecord = StreamRecords.rawBytes(Collections.singletonMap("name".getBytes(), "KevinBlandy".getBytes())).withStreamKey("mystream".getBytes());
				// 获取连接
				RedisConnection redisConnection = this.redisConnectionFactory.getConnection();
				RecordId recordId = redisConnection.xAdd(byteRecord);
				// 是否是自动生成的
				boolean autoGenerated = recordId.shouldBeAutoGenerated();
				// id值
				String value = recordId.getValue();
				// 序列号部分
				long sequence = recordId.getSequence();
				// 时间戳部分
				long timestamp = recordId.getTimestamp();
			}
		}
	
	# 通过 RedisTemplate 写入
		public class RedisStreamTest {
		
			@Autowired
			private StringRedisTemplate stringRedisTemplate;
			
			public void test () {
				// 创建消息记录, 以及指定stream
				StringRecord stringRecord = StreamRecords.string(Collections.singletonMap("name", "KevinBlandy")).withStreamKey("mystream");
				RecordId recordId = this.stringRedisTemplate.opsForStream().add(stringRecord);
				// 是否是自动生成的
				boolean autoGenerated = recordId.shouldBeAutoGenerated();
				// id值
				String value = recordId.getValue();
				// 序列号部分
				long sequence = recordId.getSequence();
				// 时间戳部分
				long timestamp = recordId.getTimestamp();
			}
		}
	
	# RecordId
		* 表示消息id, 在添加的时候, 可以自定义id, 也可以由redis自动生成
		* 静态方法
			RecordId of(@Nullable String value)
			RecordId of(long millisecondsTime, long sequenceNumber)
			RecordId autoGenerate()
				* 由redis自己生成


------------------------
redis-stream 随机消费   |
------------------------
	# 使用 StreamOperations 的 read() api 进行消息的读取

------------------------
redis-stream 阻塞消费   |
------------------------
	# 添加配置到ioc: StreamMessageListenerContainer<K, V extends Record<K, ?>>
	# 静态方法
		StreamMessageListenerContainer<String, MapRecord<String, String, String>> create(RedisConnectionFactory connectionFactory)
		<K, V extends Record<K, ?>> StreamMessageListenerContainer<K, V> create(RedisConnectionFactory connectionFactory,StreamMessageListenerContainerOptions<K, V> options)

	# 也可以通过 Builder 创建
		@Component
		public class StreamConsumerRunner implements ApplicationRunner, DisposableBean {

			static final Logger LOGGER = LoggerFactory.getLogger(StreamConsumerRunner.class);

			@Value("${redis.stream.consumer}")
			private String consumer;

			@Autowired
			RedisConnectionFactory redisConnectionFactory;

			@Autowired
			ThreadPoolTaskExecutor threadPoolTaskExecutor;
			
			@Autowired
			StreamMessageListener streamMessageListener;

			@Autowired
			StringRedisTemplate stringRedisTemplate;

			private StreamMessageListenerContainer<String, MapRecord<String, String, String>> streamMessageListenerContainer;

			@Override
			public void run(ApplicationArguments args) throws Exception {
				
				RecordId recordId = this.stringRedisTemplate.opsForStream().add("channel", Collections.singletonMap("tryCreat", ""));
				
				LOGGER.info("stream {} 初始化：{}", "channel", recordId);
				
				try {
					String result = this.stringRedisTemplate.opsForStream().createGroup("channel", "group");
					LOGGER.info("消费组 {} 创建：{}", "group", result);
				} catch (Exception e) {
					LOGGER.error("消费组创建失败:{}", e.getMessage());
				}

				StreamMessageListenerContainerOptions<String, MapRecord<String, String, String>> streamMessageListenerContainerOptions = StreamMessageListenerContainerOptions
						.builder()
						// 一次最多拉取多少消息
						.batchSize(10)
						// 执行轮询的线程（不是执行消费的线程池，异步消费消息需要自己实现）
						.executor(this.threadPoolTaskExecutor)
						// 异常处理器
						.errorHandler(new ErrorHandler() {
							@Override
							public void handleError(Throwable t) {
								// throw new RuntimeException(t);
								t.printStackTrace();
							}
						})
						// 阻塞消费，不超时
						.pollTimeout(Duration.ZERO)
						// 序列化器
						.serializer(new StringRedisSerializer())
						.build();

				// 创建 Container
				Subscription subscription = StreamMessageListenerContainer<String, MapRecord<String, String, String>> streamMessageListenerContainer = StreamMessageListenerContainer
						.create(this.redisConnectionFactory, streamMessageListenerContainerOptions);
				
				// 群组消费：开始接收消息，设置为手动消费
				Subscription subscription = streamMessageListenerContainer.receive(Consumer.from("group", 
						"consumer-1"), StreamOffset.create("chanel", ReadOffset.lastConsumed()), this.streamMessageListener);
				

				// 非群组消费
				streamMessageListenerContainer.receive(StreamOffset.create("stream", ReadOffset.latest()), new StreamListener<String, MapRecord<String,String,String>>() {
					@Override
					public void onMessage(MapRecord<String, String, String> message) {
						
					}
				});

				this.streamMessageListenerContainer = streamMessageListenerContainer;
				
				this.streamMessageListenerContainer.start();

			}

			@Override
			public void destroy() throws Exception {
				this.streamMessageListenerContainer.stop();
			}
		}

	# Subscription
		* 这是监听消费后，返回的句柄
		* 它有一些方法可以操作消费者
			boolean isActive();
			void cancel() throws DataAccessResourceFailureException;
			boolean await(Duration timeout) throws InterruptedException;
		

	# 实例方法
		* 监听消费
			Subscription receive(StreamOffset<K> streamOffset, StreamListener<K, V> listener)
			Subscription receive(Consumer consumer, StreamOffset<K> streamOffset, StreamListener<K, V> listener)

			Subscription receiveAutoAck(Consumer consumer, StreamOffset<K> streamOffset, StreamListener<K, V> listener)
			Subscription register(StreamReadRequest<K> streamRequest, StreamListener<K, V> listener)
		
		* 移除消费者
			void remove(Subscription subscription)
	
	
	
	# 自定义监听器实现接口: StreamListener
		@FunctionalInterface
		public interface StreamListener<K, V extends Record<K, ?>> {
			void onMessage(V message);
		}
	
		import org.slf4j.Logger;
		import org.slf4j.LoggerFactory;
		import org.springframework.beans.factory.annotation.Autowired;
		import org.springframework.data.redis.connection.stream.MapRecord;
		import org.springframework.data.redis.core.StringRedisTemplate;
		import org.springframework.data.redis.stream.StreamListener;
		import org.springframework.stereotype.Component;

		import io.streamer.common.constant.RedisStreamGroup;

		@Component
		public class StreamMessageListener implements StreamListener<String, MapRecord<String, String, String>>{
			
			static final Logger LOGGER = LoggerFactory.getLogger(StreamMessageListener.class);
			
			@Autowired
			StringRedisTemplate stringRedisTemplate;
			
			@Override
			public void onMessage(MapRecord<String, String, String> message) {
				
				LOGGER.info("MessageId: " + message.getId());
				LOGGER.info("Stream: " + message.getStream());
				LOGGER.info("Body: " + message.getValue());		
				
				this.stringRedisTemplate.opsForStream().acknowledge(RedisStreamGroup.CHANNEL, message);
			}
		}

		
------------------------
redis-stream 消息确认   |
------------------------
	Long redisConnectionFactory.getConnection().streamCommands().xAck(key, group, recordIds);
	Long stringRedisTemplate.acknowledge(K key, String group, String... recordIds);

-----------------------------
redis-stream apis			|
-----------------------------
	# Record<S, V> 	, 消息类型接口
		* 子实现
			MapRecord<S, K, V>
				ByteBufferRecord<ByteBuffer, ByteBuffer, ByteBuffer> 
				ByteRecord<byte[], byte[], byte[]>
				StringRecord<String, String, String>

	# StreamOperations<K, HK, HV> extends HashMapperProvider<HK, HV> , stream 的redistemlate api
		Long acknowledge(K key, String group, String... recordIds)
		Long acknowledge(K key, String group, RecordId... recordIds)
		Long acknowledge(String group, Record<K, ?> record)
			* 收到确认消息

		RecordId add(K key, Map<? extends HK, ? extends HV> content)
		RecordId add(MapRecord<K, ? extends HK, ? extends HV> record)
		RecordId add(Record<K, ?> record)

		Long delete(K key, String... recordIds)
		Long delete(Record<K, ?> record)
		Long delete(K key, RecordId... recordIds)

		String createGroup(K key, String group)
		String createGroup(K key, ReadOffset readOffset, String group)

		Boolean deleteConsumer(K key, Consumer consumer)
		Boolean destroyGroup(K key, String group)

		Long size(K key)

		List<MapRecord<K, HK, HV>> range(K key, Range<String> range)
		List<MapRecord<K, HK, HV>> range(K key, Range<String> range, Limit limit)

		<V> List<ObjectRecord<K, V>> range(Class<V> targetType, K key, Range<String> range)
		<V> List<ObjectRecord<K, V>> range(Class<V> targetType, K key, Range<String> range, Limit limit)

		List<MapRecord<K, HK, HV>> read(StreamOffset<K>... streams)
		<V> List<ObjectRecord<K, V>> read(Class<V> targetType, StreamOffset<K>... streams)
		List<MapRecord<K, HK, HV>> read(StreamReadOptions readOptions, StreamOffset<K>... streams)
		<V> List<ObjectRecord<K, V>> read(Class<V> targetType, StreamReadOptions readOptions, StreamOffset<K>... streams)
		List<MapRecord<K, HK, HV>> read(Consumer consumer, StreamOffset<K>... streams)
		<V> List<ObjectRecord<K, V>> read(Class<V> targetType, Consumer consumer, StreamOffset<K>... streams)
		List<MapRecord<K, HK, HV>> read(Consumer consumer, StreamReadOptions readOptions, StreamOffset<K>... streams)
		List<ObjectRecord<K, V>> read(Class<V> targetType, Consumer consumer, StreamReadOptions readOptions, StreamOffset<K>... streams)

		List<MapRecord<K, HK, HV>> reverseRange(K key, Range<String> range)
		List<MapRecord<K, HK, HV>> reverseRange(K key, Range<String> range, Limit limit)
		<V> List<ObjectRecord<K, V>> reverseRange(Class<V> targetType, K key, Range<String> range)
		<V> List<ObjectRecord<K, V>> reverseRange(Class<V> targetType, K key, Range<String> range, Limit limit)

		Long trim(K key, long count)

		<V> HashMapper<V, HK, HV> getHashMapper(Class<V> targetType)
		
		
		XInfoConsumers consumers(K key, String group);
		XInfoGroups groups(K key);
		XInfoStream info(K key);

		PendingMessagesSummary pending(K key, String group);
		PendingMessages pending(K key, Consumer consumer)
		PendingMessages pending(K key, String group, Range<?> range, long count)
		PendingMessages pending(K key, String group, Range<?> range, long count)
