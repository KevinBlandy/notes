------------
函数
------------
	
	# 函数的定义
		
		// 定义
		int sum(int a, int b) {
			return a + b;
		}
		
		// 调用
		int ret = sum(1, 2);
		
		* 返回值类型，如果没返回值，则定义为 void
		* 函数名称
		* 参数列表
		* 函数体
		* 返回值
	

	# 参数
		
		* 如果没参数，可以为空或者是 void
		* 参数可以不命名，只提供类型，表示函数体内用不到，但是调用一定要传
		
			void foo (int, string title){}
			foo(0, "");
		
		* 函数的参数会发生类型的隐式转换

			int foo (int x){
				cout << x << endl;
			};

			foo(3.14); // 3
	
	# 局部变量
	
		* 形参以及函数体内，定义在栈上的变量都属于局部变量。仅在函数内部可用，且会覆盖外层作用域中的同名变量。
		* 方法结束，这些栈上的数据会自动释放。这些数据成为：自动对象。
		
		* 未初始化的局部变量，会产生未定义的值。
		
		* static 的局部变量，不会被释放，而是全局存在，直到程序结束
		
			void foo (){
				// static 变量，仅在当前函数内部可以被访问
				// static 变量未初始化，默认值为 0
				static int;
				cout << ++ counter << endl;
			}
			foo();  // 1
			foo();	// 2
	
	
	# 函数声明
		
		* 和变量一样，函数也可以多次声明，但是只能定义一次。
		* 如果声明的函数用不到，则可以不用提供实现。
		* 函数的声明没有函数体，形参不需要声明变量的名称。
		
			// 声明函数
			void foo ();
			// 如果在编译时没有找到 foo 的实现，则会异常
			// undefined reference to `foo()'
			foo();
		
		* 函数声明应该放在头文件中，定义实现的源码文件应该包含声名的头文件（编译器负责检查声明和实现是否一致）。
		
	
	# 值传递还是引用传递
	
		* 在我的理解，本质上，都是值传递。只是说有些参数传递的是对象的引用，从而可以导致修改到引用的对象
		
		* 值传递，对形参的修改不会影响到外部的实参
			
			// 基本类型
			void foo (int x){	x = 12;	}
			
			// struct
			struct foo { int id; };
			void bar (foo foo) { foo.id = 10010; }; // 修改的是拷贝后的内存
			
			// 向量
			void bar (vector<int> list) {
				list.push_back(99);
			}
			
			
		
		* 引用传递，对形参的修改会影响到实参
		
			// 引用
			void bar (int &num) { num = 15; }
			
			// 指针
			void bar (int *num) { *num = 15; }
		
		* 遇到大型对象，例如 string 作为参数的时候，尽量用引用传递，避免内存拷贝
		* 如果函数内部不需要修改引用传递参数的值，最好将其设置为 const
		* 通过引用传递的参数，可以把输入参数，当成输出参数，类似于 go 中的用法
		
		

			
			

