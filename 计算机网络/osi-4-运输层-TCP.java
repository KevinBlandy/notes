--------------------
TCP - 可靠传输
--------------------
	# 停止等待协议
		* ​“停止等待” 就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。
	
		* 超时重传
			* 超时重传：发送方只要超过了一段时间仍然没有收到确认，就认为刚才发送的分组丢失了，因而重传前面发送过的分组。
			* 在每发送完一个分组设置一个超时计时器。如果在超时计时器到期之前收到了对方的确认，就撤销已设置的超时计时器。

			1. 发送完一个分组后，必须暂时保留已发送的分组的副本（为发生超时重传时使用）​。只有在收到相应的确认后才能清除暂时保留的分组副本。
			2. 分组和确认分组都必须进行编号。这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认。
			3. 超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些。
		

		* 自动重传请求ARQ (Automatic Repeat reQuest)
			* 确认丢失
				1. sender 发送出去分组，receiver 收到后返回 ACK
				2. 但是由于某些原因，sender 没有及时收到 ACK，分组超时，sender 再次发送分组
				3. receiver 再次收到相同的分组，进行两个操作
					1. 丢弃重复的分组，不向上层交付
					2. 再次返回这个分组的 ACK
				
			
			* 确认迟到
				1. receiver 收到后分组后返回 ACK(1)
				2. 但是由于某些原因，sender 没有及时收到 ACK，分组超时，sender 再次发送分组
				3. receiver 收到重复的分组后返回 ACK(2)
				4. sender 这次收到了 ACK(2)，于是继续发送下一个分组
				5. 突然，第一次返回的 ACK(1) 现在才到达（迟到的ACK），sender 直接丢弃它。
	
		
		* 信道利用率
			* 停止等待协议的优点是简单，但缺点是信道利用率太低
		
	
	# 流水线传输
		* 流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停顿下来等待对方的确认。
		* 这样可使信道上一直有数据不间断地在传送。显然，这种传输方式可以获得很高的信道利用率。


		* 连续 ARQ 协议
			1. 发送方同时发送 N 个分组，不必逐个等待确认
			2. 每收到一个 ACK，则窗口向前移动一个分组位置，也就是说可以发送下一个分组
			3. 接收方采用累计确认，也就是说不是逐个确认分组，而是在收到几个分组后，对按序到达的最后一个分组发送确认，这就表示：到这个分组为止的所有分组都已正确收到了。
		
		* 累计确认，有点是容易实现
			
--------------------
TCP - 报文格式
--------------------
	 0                   1                   2                   3   
	 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+----------------------------------------+-----------+
	|          Source Port          |       Destination Port        |										 |			 |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+										 |			 |
	|                        Sequence Number                        |										 |			 |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+										 |			 |
	|                    Acknowledgment Number                      |										 |			 |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	固定 20 字节首部					 | Header    |
	|  Data |           |U|A|P|R|S|F|                               |										 |			 |
	| Offset| Reserved  |R|C|S|S|Y|I|            Window             |										 |			 |
	|       |           |G|K|H|T|N|N|                               |										 |			 |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+										 |			 |
	|           Checksum            |         Urgent Pointer        |										 |			 |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+----------------------------------------+			 |
	|                    Options                    |    Padding    |	根据需要而增加的选项(4n字节，n是整数)|			 |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+----------------------------------------+--------—--+
	|                             data                              |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

	* TCP首部的最小长度是20字节。
	
	Source Port / Destination Port
		* 源端口和目的端口，各占 2 字节
	
	Sequence Number
		* 序列号，4 字节。范围是 [0 - (2 ^ 32 - 1)]，即 [0 - 4 294 967 296] 个序号。
		* 报文段序号，TCP 是面向字节流的。在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。
		* 整个要传送的字节流的起始序号必须在连接建立时设置。
		
		* Sequence Number 字段值则指的是本报文段所发送的数据的第一个字节的序号。
			* 例如：一报文段的序号字段值是 301（起始），而携带的数据共有 100 字节。
			* 这就表明：本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是 400。
			* 显然，下一个报文段（如果还有的话）的数据序号应当从 401 开始，即下一个报文段的序号字段值应为 401。

		* 序号使用 (mod 2 ^ 32)运算，也就是说需要增加到 (2 ^ 32 - 1) 后又重新回到 0。

	Acknowledgment Number 
		* 确认号，4 字节。
		* 是期望收到对方下一个报文段的第一个数据字节的序号。
		* 例如：
			A -> B [Sequence Number = 501, Data Length = 200 Bytes]
			A <- B [Acknowledgment Number = 701]  // B 期望收到 A 的下一个数据序号是701，于是 B 在发送给 A 的确认报文段中把确认号置为701
		
		* 若确认号 = N，则表明：到序号 N - 1 为止的所有数据都已正确收到。
		* 序号字段有32位长，可对4 GB（即4千兆字节）的数据进行编号。在一般情况下可保证当序号重复使用时，旧序号的数据早已通过网络到达终点了。

	Data Offset
		* 数据偏移，4 位
		* 即 TCP 报文段的 “数据起始处” 距离TCP报文段的起始处有多远（实际上是指出TCP报文段的首部长度）
		* 注意，“数据偏移”的单位是 32 位字（即以 4 字节长的字为计算单位）​，4位二进制数能够表示的最大十进制数字是15。
		* 因此数据偏移的最大值是 60 字节 (15 x 4)，这也是 TCP 首部的最大长度（即选项 Options 长度不能超过40字节）​。


	Reserved
		* 保留，占 6 位
		* 保留为今后使用，但目前应置为0。
	
	紧急 URG (URGent) 1 位
		* 当URG = 1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)，而不要按原来的排队顺序来传送。
		* 当URG 置 1时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。这时要与首部中紧急指针(Urgent Pointer)字段配合使用。


	确认ACK (ACKnowlegment) 1 位
		* 仅当 ACK = 1 时确认号字段才有效。
		* 当 ACK = 0 时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
	
	推送 PSH (PuSH) 1 位
	 	* 当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。
		* 在这种情况下，TCP就可以使用推送(push)操作。这时，发送方TCP把PSH置1，并立即创建一个报文段发送出去。
		* 接收方 TCP 收到 PSH = 1 的报文段，就尽快地（即“推送”向前）交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。
		
		* 虽然应用程序可以选择推送操作，但推送操作还很少使用。
	
	复位RST (ReSeT) 1 位
		* 当 RST = 1 时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因）​，必须释放连接，然后再重新建立运输连接。
		* RST 置 1 还用来拒绝一个非法的报文段或拒绝打开一个连接。
		* RST 也可称为重建位或重置位。
	
	同步SYN (SYNchronization) 1 位
		* 在连接建立时用来同步序号。
		* 当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。
		* 对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。
		
		* 因此，SYN 置为 1 就表示这是一个连接请求或连接接受报文。
	
	 终止FIN (FINis，意思是“完”​、​“终”) 1 位
		* 用来释放一个连接。
		* 当 FIN = 1 时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。
	
	
	Window 2 字节
		* 窗口，值为 0 - (2 ^ 16 - 1) 之间的整数。
		* 指的是发送本报文段的一方的接收窗口（而不是自己的发送窗口）
		* 窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。
		* 之所以要有这个限制，是因为接收方的数据缓存空间是有限的。
		* 总之，窗口值作为接收方让发送方设置其发送窗口的依据。
		* 例如
			* 设确认号是 701，窗口字段是 1000。
			* 这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 个字节数据（字节序号是701～1 700）的接收缓存空间。
		
		* 总之，窗口字段明确指出了现在允许对方发送的数据量。窗口值是经常在动态变化着。
	
	检验和，2字节
		* 检验和字段检验的范围包括首部和数据这两部分。
		* 和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。
		* 伪首部的格式与UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）​，把第5字段中的UDP长度改为TCP长度。

			+--------+--------+--------+--------+
			|           Source Address          |
			+--------+--------+--------+--------+
			|         Destination Address       |
			+--------+--------+--------+--------+
			|  zero  |  PTCL  |    TCP Length   |
			+--------+--------+--------+--------+

		
		* 接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用IPv6，则相应的伪首部也要改变。
	
	Urgent Pointer（紧急指针），2字节
		* 仅在URG = 1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）​。
		* 因此，紧急指针指出了紧急数据的末尾在报文段中的位置。
		
		* 当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。
		* 注意，即使窗口为零时也可发送紧急数据。
	
	Option 选项，长度可变，最长可达40字节
		* 当没有使用“选项”时，TCP的首部长度是20字节。

		* 最大报文段长度 MSS (Maximum Segment Size)[RFC 879]​
			* 指的是，每一个 TCP 报文段中的数据字段的最大长度。
			* 如果太小，网络利用率低（发一个字节的内容，要增加40字节的首部 = IP 20 字节 + TCP 20 字节）
			* 如果太长，那么在IP层传输时就有可能要分解成多个短数据报片，可能会增大开销（重传）

			* MSS应尽可能大些，只要在IP层传输时不需要再分片就行。
			* 在连接建立的过程中，双方都把自己能够支持的MSS写入这一字段，以后就按照这个数值传送数据，两个传送方向可以有不同的MSS值。
			* 主机未填写这一项，则 MSS 的默认值是536字节长。因此，所有在因特网上的主机都应能接受的报文段长度是 536 + 20（固定首部长度）= 556字节。
		
		* 窗口扩大选项、时间戳选项[RFC 1323]
			* 为了扩大窗口。占 3 字节，其中有一个字节表示移位值 S。
			* 新的窗口值等于 TCP 首部中的窗口位数从 16 增大到(16 + S)。
			* 移位值允许使用的最大值是 14，相当于窗口最大值增大到 2 ^ (16 + 14) - 1 = 2 ^ 30 - 1。
			* 这个选项可以在双方初始建立TCP连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送 S = 0 的选项，使窗口大小回到16。

			* 时间戳选项占 10 字节，其中最主要的字段 “时间戳值” 字段（4字节）和 “时间戳回送回答” 字段（4字节）​。
			* 时间戳选项有以下两个功能：
				1. 用来计算往返时间RTT
					* 发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。
					* 因此，发送方在收到确认报文后，可以准确地计算出RTT来。

				2. 用于处理TCP序号超过2 ^ 32的情况
					* 这又称为防止序号绕回 PAWS (Protect Against Wrapped Sequence numbers)。
					* 序号只有32位，而每增加2 ^ 32个序号就会重复使用原来用过的序号。
					* 当使用高速网络时，在一次TCP连接的数据传送中序号很可能会被重复使用。
						* 例如，若用1Gb/s的速率发送报文段，则不到 35 秒钟数据字节的序号就会重复。
					* 为了使接收方能够把新的报文段和迟到很久的报文段区分开，可以在报文段中加上这种时间戳。
		
		* 选择确认(SACK)选项 [RFC 2018]
			

	







		

		


		