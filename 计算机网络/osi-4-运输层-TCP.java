--------------------
TCP - 报文格式
--------------------
	 0                   1                   2                   3   
	 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+----------------------------------------+-----------+
	|          Source Port          |       Destination Port        |										 |			 |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+										 |			 |
	|                        Sequence Number                        |										 |			 |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+										 |			 |
	|                    Acknowledgment Number                      |										 |			 |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	固定 20 字节首部					 | Header    |
	|  Data |           |U|A|P|R|S|F|                               |										 |			 |
	| Offset| Reserved  |R|C|S|S|Y|I|            Window             |										 |			 |
	|       |           |G|K|H|T|N|N|                               |										 |			 |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+										 |			 |
	|           Checksum            |         Urgent Pointer        |										 |			 |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+----------------------------------------+			 |
	|                    Options                    |    Padding    |	根据需要而增加的选项(4n字节，n是整数)|			 |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+----------------------------------------+--------—--+
	|                             data                              |
	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

	* TCP首部的最小长度是20字节。
	
	Source Port / Destination Port
		* 源端口和目的端口，各占 2 字节
	
	Sequence Number
		* 序列号，4 字节。范围是 [0 - (2 ^ 32 - 1)]，即 [0 - 4 294 967 296] 个序号。
		* 报文段序号，TCP 是面向字节流的。在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。
		* 整个要传送的字节流的起始序号必须在连接建立时设置。
		
		* Sequence Number 字段值则指的是本报文段所发送的数据的第一个字节的序号。
			* 例如：一报文段的序号字段值是 301（起始），而携带的数据共有 100 字节。
			* 这就表明：本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是 400。
			* 显然，下一个报文段（如果还有的话）的数据序号应当从 401 开始，即下一个报文段的序号字段值应为 401。

		* 序号使用 (mod 2 ^ 32)运算，也就是说需要增加到 (2 ^ 32 - 1) 后又重新回到 0。

	Acknowledgment Number 
		* 确认号，4 字节。
		* 是期望收到对方下一个报文段的第一个数据字节的序号。
		* 例如：
			A -> B [Sequence Number = 501, Data Length = 200 Bytes]
			A <- B [Acknowledgment Number = 701]  // B 期望收到 A 的下一个数据序号是701，于是 B 在发送给 A 的确认报文段中把确认号置为701
		
		* 若确认号 = N，则表明：到序号 N - 1 为止的所有数据都已正确收到。
		* 序号字段有32位长，可对4 GB（即4千兆字节）的数据进行编号。在一般情况下可保证当序号重复使用时，旧序号的数据早已通过网络到达终点了。

	Data Offset
		* 数据偏移，4 位
		* 即 TCP 报文段的 “数据起始处” 距离TCP报文段的起始处有多远（实际上是指出TCP报文段的首部长度）
		* 注意，“数据偏移”的单位是 32 位字（即以 4 字节长的字为计算单位）​，4位二进制数能够表示的最大十进制数字是15。
		* 因此数据偏移的最大值是 60 字节 (15 x 4)，这也是 TCP 首部的最大长度（即选项 Options 长度不能超过40字节）​。


	Reserved
		* 保留，占 6 位
		* 保留为今后使用，但目前应置为0。
	
	紧急 URG (URGent) 1 位
		* 当URG = 1时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)，而不要按原来的排队顺序来传送。
		* 当URG 置 1时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。这时要与首部中紧急指针(Urgent Pointer)字段配合使用。


	确认ACK (ACKnowlegment) 1 位
		* 仅当 ACK = 1 时确认号字段才有效。
		* 当 ACK = 0 时，确认号无效。TCP规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
	
	推送 PSH (PuSH) 1 位
	 	* 当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能够收到对方的响应。
		* 在这种情况下，TCP就可以使用推送(push)操作。这时，发送方TCP把PSH置1，并立即创建一个报文段发送出去。
		* 接收方 TCP 收到 PSH = 1 的报文段，就尽快地（即“推送”向前）交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。
		
		* 虽然应用程序可以选择推送操作，但推送操作还很少使用。
	
	复位RST (ReSeT) 1 位
		* 当 RST = 1 时，表明TCP连接中出现严重差错（如由于主机崩溃或其他原因）​，必须释放连接，然后再重新建立运输连接。
		* RST 置 1 还用来拒绝一个非法的报文段或拒绝打开一个连接。
		* RST 也可称为重建位或重置位。
	
	同步SYN (SYNchronization) 1 位
		* 在连接建立时用来同步序号。
		* 当 SYN = 1 而 ACK = 0 时，表明这是一个连接请求报文段。
		* 对方若同意建立连接，则应在响应的报文段中使 SYN = 1 和 ACK = 1。
		
		* 因此，SYN 置为 1 就表示这是一个连接请求或连接接受报文。
	
	 终止FIN (FINis，意思是“完”​、​“终”) 1 位
		* 用来释放一个连接。
		* 当 FIN = 1 时，表明此报文段的发送方的数据已发送完毕，并要求释放运输连接。
	
	
	Window 2 字节
		* 窗口，值为 0 - (2 ^ 16 - 1) 之间的整数。
		* 指的是发送本报文段的一方的接收窗口（而不是自己的发送窗口）
		* 窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量。
		* 之所以要有这个限制，是因为接收方的数据缓存空间是有限的。
		* 总之，窗口值作为接收方让发送方设置其发送窗口的依据。
		* 例如
			* 设确认号是 701，窗口字段是 1000。
			* 这就表明，从 701 号算起，发送此报文段的一方还有接收 1000 个字节数据（字节序号是701～1 700）的接收缓存空间。
		
		* 总之，窗口字段明确指出了现在允许对方发送的数据量。窗口值是经常在动态变化着。
	
	检验和，2字节
		* 检验和字段检验的范围包括首部和数据这两部分。
		* 和UDP用户数据报一样，在计算检验和时，要在TCP报文段的前面加上12字节的伪首部。
		* 伪首部的格式与UDP用户数据报的伪首部一样。但应把伪首部第4个字段中的17改为6（TCP的协议号是6）​，把第5字段中的UDP长度改为TCP长度。

			+--------+--------+--------+--------+
			|           Source Address          |
			+--------+--------+--------+--------+
			|         Destination Address       |
			+--------+--------+--------+--------+
			|  zero  |  PTCL  |    TCP Length   |
			+--------+--------+--------+--------+

		
		* 接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用IPv6，则相应的伪首部也要改变。
	
	Urgent Pointer（紧急指针），2字节
		* 仅在URG = 1时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据）​。
		* 因此，紧急指针指出了紧急数据的末尾在报文段中的位置。
		
		* 当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。
		* 注意，即使窗口为零时也可发送紧急数据。
	
	Option 选项，长度可变，最长可达40字节
		* 当没有使用“选项”时，TCP的首部长度是20字节。

		* 最大报文段长度 MSS (Maximum Segment Size)[RFC 879]​
			* 指的是，每一个 TCP 报文段中的数据字段的最大长度。
			* 如果太小，网络利用率低（发一个字节的内容，要增加40字节的首部 = IP 20 字节 + TCP 20 字节）
			* 如果太长，那么在IP层传输时就有可能要分解成多个短数据报片，可能会增大开销（重传）

			* MSS应尽可能大些，只要在IP层传输时不需要再分片就行。
			* 在连接建立的过程中，双方都把自己能够支持的MSS写入这一字段，以后就按照这个数值传送数据，两个传送方向可以有不同的MSS值。
			* 主机未填写这一项，则 MSS 的默认值是536字节长。因此，所有在因特网上的主机都应能接受的报文段长度是 536 + 20（固定首部长度）= 556字节。
		
		* 窗口扩大选项、时间戳选项[RFC 1323]
			* 为了扩大窗口。占 3 字节，其中有一个字节表示移位值 S。
			* 新的窗口值等于 TCP 首部中的窗口位数从 16 增大到(16 + S)。
			* 移位值允许使用的最大值是 14，相当于窗口最大值增大到 2 ^ (16 + 14) - 1 = 2 ^ 30 - 1。
			* 这个选项可以在双方初始建立TCP连接时进行协商。如果连接的某一端实现了窗口扩大，当它不再需要扩大其窗口时，可发送 S = 0 的选项，使窗口大小回到16。

			* 时间戳选项占 10 字节，其中最主要的字段 “时间戳值” 字段（4字节）和 “时间戳回送回答” 字段（4字节）​。
			* 时间戳选项有以下两个功能：
				1. 用来计算往返时间RTT
					* 发送方在发送报文段时把当前时钟的时间值放入时间戳字段，接收方在确认该报文段时把时间戳字段值复制到时间戳回送回答字段。
					* 因此，发送方在收到确认报文后，可以准确地计算出RTT来。

				2. 用于处理TCP序号超过2 ^ 32的情况
					* 这又称为防止序号绕回 PAWS (Protect Against Wrapped Sequence numbers)。
					* 序号只有32位，而每增加2 ^ 32个序号就会重复使用原来用过的序号。
					* 当使用高速网络时，在一次TCP连接的数据传送中序号很可能会被重复使用。
						* 例如，若用1Gb/s的速率发送报文段，则不到 35 秒钟数据字节的序号就会重复。
					* 为了使接收方能够把新的报文段和迟到很久的报文段区分开，可以在报文段中加上这种时间戳。
		
		* 选择确认(SACK)选项 [RFC 2018]
			

	
--------------------
TCP 的运输连接管理
--------------------
	# 运输连接就有三个阶段，即：连接建立、数据传送和连接释放。
		* 运输连接的管理就是使运输连接的建立和释放都能正常地进行。
	
	
	# C/S 模式
		* TCP连接的建立采用客户服务器方式。主动发起连接建立的应用进程叫做客户(client)，而被动等待连接建立的应用进程叫做服务器(server)。
	

	# 连接的创建

		* A 是客户端，B 是服务端
		* 三次握手(three-way handshake)，连接建立

			1. A -> B
				SYN = 1		// 标志位

				seq = x		// A 的消息序列号
			
				* TCP规定，SYN报文段（即SYN = 1的报文段）不能携带数据，但要消耗掉一个序号。
				* 这时，TCP客户进程进入 SYN-SENT（同步已发送）状态。
			
			2. B <- A
				SYN = 1		// 标志位
				ACK = 1		// 标志位

				seq = y		// B 的消息序列号
				ack = x + 1	// 确认了 A 的 x 消息

				* 注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。
				* 这时TCP服务器进程进入 SYN-RCVD（同步收到）状态。

			
			3. A -> B
				ACK = 1		// 标志位
				
				seq = x + 1	// 
				ack = y + 1	// 确认了 B 的 y 消息
				
				* TCP的标准规定，ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，在这种情况下，下一个数据报文段的序号仍是 seq = x + 1。
				* 这时，TCP连接已经建立，A进入 ESTABLISHED（已建立连接）状态。
				* 当 B 收到 A 的确认后，也进入 ESTABLISHED 状态。
			
		* 最后一次，A 还要继续给 B ACK 的目的主要是为了防止 “已失效的连接请求报文段” 突然又传送到了B，因而产生错误。
			1. A 给 B 发起了连接请求，未得到确认，请求丢失。
			2. A 再重传连接请求，B 收到了请求，返回确认，经过握手，连接建立，传输数据，传输完毕，关闭连接。
			3. A 第一次发起的连接请求，并没丢失，而是拥塞在了某个地方，现在这个包被 B 收到
			4. B 以为是 A 再次发起了连接请求，于是返回 ACK
				* 由于 A 现在并没有发起连接请求，于是 A 直接丢弃这个来自于 B 的 ACK，不管
				* B 迟迟没有收到来自 A 的 ACK，于是连接不会建立

	
	# 连接的释放
		* TCP连接释放过程比较复杂，数据传输结束后，通信的双方都可释放连接。
		* A 和 B 通信，连接目前是建立状态，4 次挥手断开连接

			1. A -> B：A 主动发起关闭请求（我传完了，先关为敬）
				FIN = 1	// 标志位

				seq = u	// A 序列号，即前面传送的最后一个字节的序号 + 1

				* 这时 A 进入 FIN-WAIT-1（终止等待1）状态，等待B的确认。
				* 注意，TCP规定，FIN报文段即使不携带数据，它也消耗掉一个序号。

			
			2. B -> A：B 收到连接释放报文段后即发出确认（中，收到，我看看我还有要交代的没）
		
				ACK = 1				// 标志位
				
				seq = v				// B 消息的序列号，等于B前面已传送过的数据的最后一个字节的序号加1
				ack = u + 1			// 确认 A 消息的序列号
					
				
				* 此时，B 就进入 CLOSE-WAIT（关闭等待）状态，TCP服务器进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了。
				* 这时的 TCP 连接处于半关闭(half-close)状态，即 A 已经没有数据要发送了，但 B 若发送数据，A仍要接收。
				* 也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一些时间。
			
			3. A 收到来自 B 的确认后，就进入 FIN-WAIT-2（终止等待2）状态，等待 B 发出的连接释放报文段（还有几句话你要听者）。
			4. B -> A： 若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接（没了，关吧）
			
				FIN = 1			// 标志位
				ACK = 1			// 标志位

				seq = w			// B 的消息序号，在半关闭状态 B 可能又发送了一些数据
				ack = u + 1		// 重复上次已发送过的确认号 ack = u + 1
				
				* 此时，B 就进入 LAST-ACK（最后确认）状态，等待 A 的确认。
			
			5. A -> B：A在收到B的连接释放报文段后，必须对此发出确认（中，关）
				
				ACK = 1
				
				seq = u + 1		// A 自己的消息序号
				ack = w + 1		// 确认 B 的消息


				
				* 根据 TCP 标准，前面发送过的FIN报文段要消耗一个序号​。
				* 然后进入到 TIME-WAIT（时间等待）状态。

				* 注意，现在TCP连接还没有释放掉。必须经过时间等待计时器(TIME-WAIT timer)设置的时间 2 MSL 后，A 才进入到 CLOSED 状态。
			
			6. B 只收到了 A 发出的确认，就进入 CLOSED 状态。
				* 在撤销相应的传输控制块TCB后，就结束了这次的TCP连接。
				* B结束TCP连接的时间要比A早一些（A 要等 2MSL）。

	
		* MSL（Maximum Segment Lifetime），最长报文段寿命
			* RFC 793建议设为2分钟，对于现在的网络，MSL = 2分钟可能太长了一些，TCP 实现往往都设置得更小。
			* 等待 2 MSL 的原因

				1. 为了保证最后一个 A -> B （第 5 步）的 ACK 报文有足够的时间交付
					* 如果 B 长时间没有收到这个 ACK，会重传 FIN ACK（第 4 步）
					* A 收到重传后，会再次发送 ACK （第 5 步），重新启动2MSL计时器。

					* 如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到B重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段。
					* 这样，B 就无法按照正常步骤进入CLOSED状态。
	
				2. 防止 “已失效的连接请求报文段”
					* 类似于连接建立中的三次握手
			

		* 保活计时器(keepalive timer)
			* 除时间等待计时器外，TCP还设有一个保活计时器(keepalive timer)
			* 服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。
			
			* 若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75分钟发送一次。
			* 若一连发送10个探测报文段后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。
		
		


	# TCP的有限状态机
		