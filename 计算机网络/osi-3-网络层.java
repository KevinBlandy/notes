---------------------
网络层
---------------------
	# 网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务
		* 网络在发送分组时不需要先建立连接。每一个分组（也就是IP数据报）独立发送，与其前后的分组无关（不进行编号）​。
		* 网络层不提供服务质量的承诺，也就是说，所传送的分组可能出错、丢失、重复和失序（即不按序到达终点。
	

---------------------
网际协议 IP
---------------------
	# 网际协议IP 是 TCP/IP 体系中两个最主要的协议之，也是最重要的因特网标准协议之一。
	
	# 与IP协议配套使用的还有三个协议：
		* 地址解析协议 ARP (Address Resolution Protocol)
		* 网际控制报文协议 ICMP (Internet Control Message Protocol)
		* 网际组管理协议 IGMP (Internet Group Management Protocol)
	

	# 虚拟互联网络
		* 从一般的概念来讲，将网络互相连接起来要使用一些中间设备。根据中间设备所在的层次，可以有以下四种不同的中间设备
			1. 物理层使用的中间设备叫做转发器(repeater)
			2. 数据链路层使用的中间设备叫做网桥或桥接器(bridge)
			3. 网络层使用的中间设备叫做路由器(router)
			4. 在网络层以上使用的中间设备叫做网关(gateway)，用网关连接两个不兼容的系统需要在高层进行协议的转换
		

			* 由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器称为网关。
	
		* 所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的
		* 但是我们利用IP协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。
		* 这种使用IP协议的虚拟互连网络可简称为 IP 网（IP网是虚拟的，但平常不必每次都强调“虚拟”二字）​。
		* 使用IP网的好处是：当IP网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节（如具体的编址方案、路由选择协议，等等）
	

	# IP 地址及其表示方法
		
		* 有关IP最重要的文档是 RFC 791，它很早就成为了因特网的正式标准。
		* IP地址现在由因特网名字和数字分配机构 ICANN (Internet Corporation for Assigned Names and Numbers)进行分配。

		* IP地址的编址方法共经过了三个历史阶段。
			1. 分类的IP地址。这是最基本的编址方法，在1981年就通过了相应的标准协议。
			2. 子网的划分。这是对最基本的编址方法的改进，其标准RFC 950在1985年通过。
			3. 构成超网。这是比较新的无分类编址方法。1993年提出后很快就得到推广应用。
	

	# 分类的 IP 地址

		* 将IP地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成
			1. 其中第一个字段是网络号(net-id)，它标志主机（或路由器）所连接到的网络。一个网络号在整个因特网范围内必须是唯一的。
			2. 第二个字段是主机号(host-id)，它标志该主机（或路由器）​。一个主机号在它前面的网络号所指明的网络范围内必须是唯一的。
		
		* 一个IP地址在整个因特网范围内是唯一的。

			IP = {网络号, 主机号}
		

	# A 类地址: [0		网络号(8位)		| 主机号(24位)  ]
		* 网络号占 1 个字节，但是只有 7 为可用，因为第一位固定为 0
		* 网络号共有 126 ((1 << 7) - 2) 个，减去 2 的原因是有俩地址比较特殊
			1. 网络号全为 0(00000000)，是保留地址，表示本网络。
			2. 网络号全为 1(01111111)，是本地回环地址，用于本机进程之间通信使用，目标地址为回环地址的报文不会发到网络上。
				01111111 = 127 // 127.0.0.1 就这
		
		* 主机地址占 3 个字节，共有 16777216 个 ((1 << 24) - 2) 地址，减 2 的原因是因为有俩特殊地址
			1. 全 0 的主机号字段表示该IP地址是 “本主机” 所连接到的单个网络地址。
				// 例如，一主机的IP地址为 5.6.7.8，则该主机所在的网络地址就是 5.0.0.0 (主机号全部为 0)

			2. 全 1 的主机号字段表示该网络上的所有主机。
		
		* IP 地址空间共有 4294967296 (1 << 32) 个地址。整个A类地址空间共有 2147483648 (1 << 31) 个地址，占有整个IP地址空间的 50%。
			// A 类地址的第一位固定是 0，所以， A 类地址只有 31 位可用


	# B 类地址: [10		网络号(16位)	| 主机号(16位)  ]
		* 网络号字段有2字节，但前面两位（10）已经固定了，只剩下14位可以进行分配。
		* 可指派的网络数为 16383 ((1 << 14) - 1)，减 1 的原因是因为 B 类网络地址 128.0.0.0 是不指派的，可以指派的 B 类最小网络地址是 128.1.0.0 [COME06]​。

		* 该类地址每一个网络上的最大主机数是 65534 ((1 << 16) - 2)，减 2 是因为要扣除全 0 和全 1 的主机号。
		* 整个B类地址空间共约有 1073741824 (1 << 30)个地址，占整个IP地址空间的 25%。
		
	# C 类地址: [110	网络号(24位)	| 主机号( 8位)  ]
		* 网络号段占 3 个字节，还有 21 位(前三位固定了)可以进行分配，共 2097151 ((1 << 21) - 1) 个网络
		* 减 1 的原因是因为全 0 的C 类网络地址 192.0.0.0 ([11000000])也是不指派的，可以指派的C类最小网络地址是 192.0.1.0 [COME06]

		* 主机数占 1 个字节，最大主机数是 254 ((1 << 8) - 2) 个。整个 C 类地址空间共约有 536870912 (1 << 29)个地址，占整个IP地址的 12.5%。

	# D 类地址: [1110	网络号			| 多播地址		]
	# E 类地址: [1111	网络号			| 保留，今后使用]

	
	# 地址类别表

		A类：0xxxxxxx.host.host.host    (0.0.0.0 - 127.255.255.255)
		B类：10xxxxxx.net.host.host     (128.0.0.0 - 191.255.255.255)
		C类：110xxxxx.net.net.host      (192.0.0.0 - 223.255.255.255)

		网络类别	最大可指派的网络数		第一个可指派的网络号	最后一个可指派的网路号	每个网络中的最大主机数
		----------------------------------------------------------------------------------------------------------
		A			126((1 << 7) - 2)		1						126						16777214((1 << 24) - 2)
		B			16383((1 << 14) - 1)	128.1					191.255					65534((1 << 16) - 2)
		C			2097151((1 << 21) - 1)	192.0.1					223.255.255				254((1 << 8) - 2)
	
	#  一般不使用的特殊IP地址

		网络号	主机号				源地址使用	目标地址使用	代表的意思
		----------------------------------------------------------------------------------------------------------
		0		0					可以		不可以			在本网络上的本主机(HCP协议)
		0		host-id				可以		不可			在本网络上的某个主机 host-id
		全1		全1					不可		可以			只在本网络上进行广播(各路由器均不转发)
		net-id	全1					不可		可以			对net-id上的所有主机进行广播
		127		非全0或全1的任何数	可以		可以			用作本地软件环回测试之用
	

---------------------
ARP
---------------------
	# 地址解析协议 ARP
		* 根据机器（主机或路由器）的IP地址，找出其相应的硬件地址。

		* ARP 是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。
		* 如果所要找的主机和源主机不在同一个局域网上，就无法解析出另一个局域网上主机的硬件地址
	
	# 每一个主机都设有一个ARP高速缓存(ARP cache)
		* 里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。

		* 以主机 A 通过 IP 给主机 B 发消息来说
			1. 主机 A 的 ARP 表中存在主机 B 对应的硬件地址，直接把硬件地址写入 MAC 帧，通过局域网把该帧发往此地址。
			2. 主机 A 的 ARP 表中没有主机 B 对应的硬件地址，则发起 ARP 广播。
				2.1. 主机 A 向本局域网络中的所有机器广播发送 ARP 请求分组：“我的 IP 是 209.0.0.5，硬件地址是 00-00-C0-15-AD-18，我想要知道 IP 为 209.0.0.6 的硬件地址多少？”
				2.2. 收到 ARP 请求分组的机器检查自己的 IP 是否是 209.0.0.6
					2.2.1. 如果 IP 不是自己的，不管
					2.2.2. 如果 IP 是自己的，则给主机 A 单播  “我的IP地址是 209.0.0.6，我的硬件地址是 08-00-2B-00-EE-0A”
						2.2.2.1. 如果自己的 ARP 表中还没有对方的 IP 和硬件地址映射，则顺便在自己的 ARP 表中记下，“IP 209.0.0.5 的硬件地址是 00-00-C0-15-AD-18”。
			
		* ARP 把保存在高速缓存中的每一个映射地址项目都设置生存时间（例如，10～20分钟）​，凡超过生存时间的项目就从高速缓存中删除掉。
	
		
---------------------
IP 数据报
---------------------

	# IPv4 数据报
				
		0                   1                   2                   3   
		0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--------------------+----+
	   |Version|  IHL  |Type of Service|          Total Length         |					|	 |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+					|	 |
	   |         Identification        |Flags|      Fragment Offset    |					| 首 |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+					|	 |
	   |  Time to Live |    Protocol   |         Header Checksum       |	固定20字节		|	 |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+					|	 |
	   |                       Source Address                          |					|	 |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+					| 部 |
	   |                    Destination Address                        |					|	 |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--------------------+	 |
	   |                    Options                    |    Padding    |	可变长部分		|	 |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--------------------+----+
	   |                    Data									   |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

	   * IP数据报由首部和数据两部分组成，首部的前一部分是固定长度，共20字节，是所有IP数据报必须具有的。
	   
		
		Version 4 位
			* 版本号，指IP协议的版本。通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为 4 (即IPv4)
			* 目前最高为 6，即 IPV6
		
		IHL	4 位
			* 首部长度(Internet Header Length)，注意，所表示数的单位是 32 位字(1个32位字长是4字节)，即长度为多少个 4 字节。
			* 最大值是 15 (1111)，15 x 5 = 60 字节。
			* 最小值为  5 (0101)​，相当于IP首部长度为 5 x 4 = 20 字节。
		
			* 当IP分组的首部长度不是4字节的整数倍时，必须利用最后的填充字段加以填充。
		
		Type of Service	8 位
			* 区分服务，用来获得更好的服务。
			* 这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998年IETF把这个字段改名为区分服务 DS (Differentiated Services)。
			* 只有在使用区分服务时，这个字段才起作用​。在一般的情况下都不使用这个字段[RFC 2474, 3168, 3260]​。
		
		Total Length 16 位
			* 指首部和数据之和的长度，单位为字节。
			* 总长度字段为16位，因此数据报的最大长度为 2^16 - 1 = 65535 字节。

			* 然而实际上传送这样长的数据报在现实中是极少遇到的，需要考虑 MAC 帧的 MTU(1500 字节)
			* IP协议规定，因特网中所有的主机和路由器，必须能够接受长度不超过 576 字节的数据报。
			* 这是假定上层交下来的数据长度有 512 字节（合理的长度）​，加上最长的IP首部 60 字节，再加上4字节的富裕量，就得到576字节。
			* 当主机需要发送长度超过 576 字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。
		
		Identification 16 位
			* 标识，IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。
			* 但这个 “标识” 并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。
			
			* 当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。
			* 相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。
		
		Flags 3 位
			* 标志，目前只有两位有意义。
			* 最低位记为 MF (More Fragment)。MF = 1 即表示后面“还有分片”的数据报，MF = 0 表示这已是若干数据报片中的最后一个。
			* 标志字段中间的一位记为 DF (Do not Fragment)，意思是 “不能分片”​。只有当 DF = 0 时才允许分片。
		
		Fragment Offset 13 位
			* 片偏移，较长的分组在分片后，某片在原分组中的相对位置。
			* 也就是说，相对于用户数据字段的起点，该片从何处开始，片偏移以 8个字节为偏移单位。这就是说，每个分片的长度一定是 8 字节（64位）的整数倍。
			* 这片数据的开头，在原始数据中是第几个 8 字节？

		
			* 例如，报文和首部消息总大小为：3820
				1. 固定首部 20 字节，消息为 3800 字节，每个数据报片的数据部分长度不能超过 1400 字节。
				2. 于是可以拆成 3 个分片
		
								Range		Total Length	Flags		Fragment Offset
					第 1 片		0-1399		1400+20=1420	MF=1/DF=0	0/8=0
					第 2 片		1400-2799	1400+20=1420	MF=1/DF=0	1400/8=175
					第 3 片		2800-3799	1000+20=1020	MF=0/DF=1	2800/8=350
		
		
		Time to Live 8 位
			* 生存时间，表明是数据报在网络中的寿命。
			* 由发出数据报的源点设置这个字段，其目的是防止无法交付的数据报无限制地在因特网中兜圈子（例如从路由器R1转发到R2，再转发到R3，然后又转发到R1）​，因而白白消耗网络资源。
		
			* 最初的设计是以秒作为TTL值的单位
				* 每经过一个路由器时，就把TTL减去数据报在路由器所消耗掉的一段时间。
				* 若数据报在路由器消耗的时间小于 1 秒，就把TTL值减 1。
				* 当TTL值减为零时，就丢弃这个数据报。
			
			* 现在把 TTL 字段的功能改为“跳数限制”​（名称没变）
				* 指明数据报在因特网中至多可经过多少个路由器。​
				* 路由器在转发数据报之前就把TTL值减 1，若TTL值减小到零，就丢弃这个数据报，不再转发。

				* 显然，数据报能在因特网中经过的路由器的最大数值是 255。
				* 若把 TTL 的初始值设置为1，就表示这个数据报只能在本局域网中传送，因为这个数据报一传送到局域网上的某个路由器，在被转发之前TTL值就减小到零，因而就会被这个路由器丢弃。

		
		Protocol 8 位
			* 协议，指出此数据报携带的数据是使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个处理过程。
			* 该字段的值为协议的编号，协议编号由 IANA 维护。

				协议名称	字段值		说明
				----------------------------------------------------
				ICMP		1
				IGMP		2
				IP			4			特殊的IP数据报——IP数据报再封装到IP数据报中。
				TCP			6
				EGP			8
				IGP			9
				UDP			17
				IPv6		41
				ESP			50
				OSPF		89
		
		Header Checksum 16 位
			* 首部校验和，这个字段只检验数据报的首部，但不包括数据部分。
			* 数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。
			* IP首部的检验和不采用复杂的CRC检验码而采用下面的简单计算方法(为了减小计算检验和的工作量)：

				1. 在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段置零。
				2. 用反码算术运算把所有16位字相加后，将得到的和的反码写入检验和字段。
				
				3. 接收方收到数据报后，将首部的所有16位字再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。
				4. 若首部未发生任何变化，则此结果必为0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。
		
		
		Source Address 32 位
			* 源地址

		Destination Address  32 位
			* 目标地址
		

		Options 可变长度
			* 选项，用来支持排错、测量以及安全等措施，内容很丰富。
			* 长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。
			* 有些选项项目只需要1个字节，它只包括1个字节的选项代码。
			* 有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符。
			* 最后用全0的填充字段补齐成为 4 字节的整数倍。

			* 这增加了每一个路由器处理数据报的开销，实际上这些选项很少被使用。
			* 很多路由器都不考虑IP首部的选项字段，因此新的IP版本IPv6就把IP数据报的首部长度做成固定的。


---------------------
IP 分组转发
---------------------
	# 按主机所在的网络地址来制作路由表
		* 在路由表中，对每一条路由最主要的是以下两个信息

			* 目的网络地址
			* 下一跳地址
	
	# 特定主机路由
		* 因特网所有的分组转发都是基于目的主机所在的网络，但在大多数情况下都允许有这样的特例，即对特定的目的主机指明一个路由。
		* 方便地控制网络和测试网络，以及在对网络的连接或路由表进行排错。
	

	# 默认路由
		* 可以减少路由表所占用的空间和搜索路由表所用的时间。
		* 这种转发方式在一个网络只有很少的对外连接时是很有用的。
	

	# 找到下一跳路由器
		* 当路由器收到一个待转发的数据报，在从路由表得出下一跳路由器的 IP 地址后，不是把这个地址填入IP数据报，而是送交数据链路层的网络接口软件。
		* 网络接口软件负责把下一跳路由器的 IP 地址转换成硬件地址（使用ARP）​，并将此硬件地址放在链路层的MAC帧的首部，然后根据这个硬件地址找到下一跳路由器。
		* 由此可见，当发送一连串的数据报时，上述的这种查找路由表、计算硬件地址、写入MAC帧的首部等过程，将不断地重复进行，造成了一定的开销。
	
	# 分组转发算法
		1. 从数据报的首部提取目的主机的IP地址D, 得出目的网络地址为 N。
		2. 若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址 D 转换为具体的硬件地址，把数据报封装为MAC帧，再发送此帧）​；否则就是间接交付，执行(3)。
		3. 若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。
		4. 若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(5)。
		5. 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。
		6. 报告转发分组出错。
	

---------------------
子网划分
---------------------
	# 1985年起在IP地址中又增加了一个“子网号字段”​，使两级IP地址变成为三级IP地址
		* 这种做法叫作划分子网(subnetting) [RFC 950]​，或子网寻址或子网路由选择。
		* 划分子网已成为因特网的正式标准协议。
	
	# 子网
		* 一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网(subnet)，对外界来说是透明的。
		* 子网是从网络的主机号借用若干位作为子网号 subnet-id，当然主机号也就相应减少了同样的位数，于是两级IP地址在本单位内部就变为三级IP地址。
			IP 地址 = {<网络号>, <子网号>, <主机号>}
	
		* 从其他网络发送给单位的IP数据报，仍然是根据IP数据报的目的网络号找到连接在本单位网络上的路由器。
		* 但此路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网，把IP数据报交付目的主机。
		
		* 划分子网只是把IP地址的主机号这部分进行再划分，而不改变IP地址原来的网络号。
		* 划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。
	
	
	# 子网掩码
		* 从IP数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网的划分(IP地址本身以及数据报的首部都没有包含任何有关子网划分的信息)。

		* 虽然RFC文档中没有规定子网掩码中的一串1必须是连续的，但却极力推荐在子网掩码中选用连续的1，以免出现可能发生的差错。

		* 现在因特网的标准规定：所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。
		* 如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码，默认子网掩码中 1 的位置和 IP 地址中的网络号字段net-id正好相对应。

			A类：255.0.0.0        二进制：11111111.00000000.00000000.00000000
			B类：255.255.0.0      二进制：11111111.11111111.00000000.00000000
			C类：255.255.255.0    二进制：11111111.11111111.11111111.00000000


		* 因此，若用默认子网掩码和某个不划分子网的IP地址逐位相“与”(AND)，就应当能够得出该 IP 地址的网络地址来。这样做可以不用查找该地址的类别位就能知道这是哪一类的IP地址。
			
		* 路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。
		* 在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。


		* 虽然根据已成为因特网标准协议的RFC 950文档，子网号不能为全1或全0，但随着无分类域间路由选择CIDR的广泛使用（在4.3.3节讨论）​，现在全1和全0的子网号也可以使用了，但一定要谨慎使用，要弄清你的路由器所用的路由选择软件是否支持全0或全1的子网号这种较新的用法。


	
	# 根据子网掩码计算出 IP 所属的子网的网络地址
		
		IP & 子网掩码 = 子网的网络地址
		
		* 例如
			IP = 145.13.3.10	10010001.00001101.00000011.00001010
			mask = 0xFFFFFF00	11111111.11111111.11111111.00000000		255.255.255.0


			子网地址 = IP & mask;

		
		* Golang 例子
			// IP		145.13.3.10
			var ip = uint32(0b10010001_00001101_00000011_00001010)
			// 子网掩码	255.255.255.0
			var mask = uint32(0b11111111_11111111_11111111_00000000)

			// 计算出 IP 所属的子网地址
			var ret = ip & mask

			// 解析 10 进制的子网地址为字节数组
			var addr [4]byte
			binary.BigEndian.PutUint32(addr[:], ret)

			// 解析数组为 IP
			subNetAddr := net.IP(addr[:]).To4()
			
			// 145.13.3.0
			fmt.Println(subNetAddr)

					
---------------------
使用子网时分组的转发
---------------------
	# 路由表必须包含以下三项内容
		* 目的网络地址
		* 子网掩码
		* 下一跳地址
	
	# 路由器转发分组的算法如下
		1. 从收到的数据报的首部提取目的IP地址 D。
		2. 先判断是否为直接交付。
			* 对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和 D 逐位相“与”​（AND操作）​，看结果是否和相应的网络地址匹配。

			* 若匹配，则把分组进行直接交付（当然还需要把 D 转换成物理地址，把数据报封装成帧发送出去）​，转发任务结束。
			* 否则就是间接交付，执行(3)。
		
		3. 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。
		4. 对路由表中的每一行（目的网络地址，子网掩码，下一跳地址）​，用其中的子网掩码和D逐位相“与”​（AND操作）​，其结果为 N。
			* 若 N 与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；
			* 否则，执行(5)。
		5. 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。
		6. 报告转发分组出错。

---------------------
分类编址CIDR（构成超网）
---------------------
	# 无分类编址方法，它的正式名字是无分类域间路由选择 CIDR (Classless Inter-Domain Routing，CIDR的读音是 “sider”)
		* CIDR 把 32 位的 IP 地址划分为两个部分。
			* 前面的部分是“网络前缀”(network-prefix)（或简称为“前缀”​）​，用来指明网络
			* 后面的部分则用来指明主机。
			
			* 因此CIDR使IP地址从三级编址（使用子网掩码）又回到了两级编址，但这已是无分类的两级编址。


				IP 地址 = {<网络前缀>, <主机号>}
			
			* CIDR 还使用“斜线记法”(slash notation)，或称为CIDR记法，即在IP地址后面加上斜线“/”​，然后写上网络前缀所占的位数。
			* CIDR 把网络前缀都相同的连续的IP地址组成一个“CIDR地址块”​。
				* 只要知道CIDR地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数。

				128.14.35.7/20 = 10000000000011100010001100000111

					* 128.14.35.7 的二进制表示是 10000000000011100010001100000111
					* 20，则表示是前 20 位是网络前缀（用粗体和下画线表示出）​，而前缀后面的 12 位是主机号
				
					* 那么其最大、最小地址如下：
						10000000000011100010 000000000000		// 128.14.32.0
						10000000000011100010 111111111111		// 128.14.47.255
			
					* 共有  2 ^ 12 个地址，当然，这两个主机号是全0和全1的地址一般并不使用。通常只使用在这两个地址之间的地址。
					* 可以用地址块中的最小地址和网络前缀的位数指明这个地址块。
						128.14.32.0/20
				
					* 在不需要指出地址块的起始地址时，也可把这样的地址块简称为 “/20地址块”​。
			
		
		* CIDR使用32位的地址掩码(address mask)
			* 例如 “/20“ 地址块的地址掩码是：11111111 111111111111000000000000（20个连续的1）​。
			* 斜线记法中，斜线后面的数字就是地址掩码中1的个数。
		
		* 根据地址块，还可以快速计算出最大地址和最小地址
			
			192.199.170.82/27
				* 前 27 位是前缀，占用了 IP 的前 4 字节
				* 看 IP 地址中的第 4 个字节，就是 82
				* 82 的二进制为 01010010
				* 前面 3 位(010)保持不动，因为这 3 位属于前缀（3 x 8 + 3 = 27 位）
					
				* 最小值：剩下的位全部填充 0：01000000	= 64	=	192.199.170.64
				* 最大值：剩下的位全部填充 1：01011111	= 95	=	192.199.170.95
		
		* 可以把点分十进制中低位连续的 0 省略：地址块 10.0.0.0/10 可简写为 10/10
		* 还有一种前缀表示法：在网络前缀的后面加一个星号 *，如：0000101000* 意思是：在星号* 之前是网络前缀，而星号*表示IP地址中的主机号，可以是任意值。
		* 前缀位数不是8的整数倍时，需要进行简单的计算才能得到一些地址信息。
			
	# 构成超网(supernetting)
		

				

