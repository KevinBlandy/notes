---------------------
网络层
---------------------
	# 网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务
		* 网络在发送分组时不需要先建立连接。每一个分组（也就是IP数据报）独立发送，与其前后的分组无关（不进行编号）​。
		* 网络层不提供服务质量的承诺，也就是说，所传送的分组可能出错、丢失、重复和失序（即不按序到达终点。
	

---------------------
网际协议 IP
---------------------
	# 网际协议IP 是 TCP/IP 体系中两个最主要的协议之，也是最重要的因特网标准协议之一。
	
	# 与IP协议配套使用的还有三个协议：
		* 地址解析协议 ARP (Address Resolution Protocol)
		* 网际控制报文协议 ICMP (Internet Control Message Protocol)
		* 网际组管理协议 IGMP (Internet Group Management Protocol)
	

	# 虚拟互联网络
		* 从一般的概念来讲，将网络互相连接起来要使用一些中间设备。根据中间设备所在的层次，可以有以下四种不同的中间设备
			1. 物理层使用的中间设备叫做转发器(repeater)
			2. 数据链路层使用的中间设备叫做网桥或桥接器(bridge)
			3. 网络层使用的中间设备叫做路由器(router)
			4. 在网络层以上使用的中间设备叫做网关(gateway)，用网关连接两个不兼容的系统需要在高层进行协议的转换
		

			* 由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器称为网关。
	
		* 所谓虚拟互连网络也就是逻辑互连网络，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的
		* 但是我们利用IP协议就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络。
		* 这种使用IP协议的虚拟互连网络可简称为 IP 网（IP网是虚拟的，但平常不必每次都强调“虚拟”二字）​。
		* 使用IP网的好处是：当IP网上的主机进行通信时，就好像在一个单个网络上通信一样，它们看不见互连的各网络的具体异构细节（如具体的编址方案、路由选择协议，等等）
	

	# IP 地址及其表示方法
		
		* 有关IP最重要的文档是 RFC 791，它很早就成为了因特网的正式标准。
		* IP地址现在由因特网名字和数字分配机构 ICANN (Internet Corporation for Assigned Names and Numbers)进行分配。

		* IP地址的编址方法共经过了三个历史阶段。
			1. 分类的IP地址。这是最基本的编址方法，在1981年就通过了相应的标准协议。
			2. 子网的划分。这是对最基本的编址方法的改进，其标准RFC 950在1985年通过。
			3. 构成超网。这是比较新的无分类编址方法。1993年提出后很快就得到推广应用。
	

	# 分类的 IP 地址

		* 将IP地址划分为若干个固定类，每一类地址都由两个固定长度的字段组成
			1. 其中第一个字段是网络号(net-id)，它标志主机（或路由器）所连接到的网络。一个网络号在整个因特网范围内必须是唯一的。
			2. 第二个字段是主机号(host-id)，它标志该主机（或路由器）​。一个主机号在它前面的网络号所指明的网络范围内必须是唯一的。
		
		* 一个IP地址在整个因特网范围内是唯一的。

			IP = {网络号, 主机号}
		

	# A 类地址: [0		网络号(8位)		| 主机号(24位)  ]
		* 网络号占 1 个字节，但是只有 7 为可用，因为第一位固定为 0
		* 网络号共有 126 ((1 << 7) - 2) 个，减去 2 的原因是有俩地址比较特殊
			1. 网络号全为 0(00000000)，是保留地址，表示本网络。
			2. 网络号全为 1(01111111)，是本地回环地址，用于本机进程之间通信使用，目标地址为回环地址的报文不会发到网络上。
				01111111 = 127 // 127.0.0.1 就这
		
		* 主机地址占 3 个字节，共有 16777216 个 ((1 << 24) - 2) 地址，减 2 的原因是因为有俩特殊地址
			1. 全 0 的主机号字段表示该IP地址是 “本主机” 所连接到的单个网络地址。
				// 例如，一主机的IP地址为 5.6.7.8，则该主机所在的网络地址就是 5.0.0.0 (主机号全部为 0)

			2. 全 1 的主机号字段表示该网络上的所有主机。
		
		* IP 地址空间共有 4294967296 (1 << 32) 个地址。整个A类地址空间共有 2147483648 (1 << 31) 个地址，占有整个IP地址空间的 50%。
			// A 类地址的第一位固定是 0，所以， A 类地址只有 31 位可用


	# B 类地址: [10		网络号(16位)	| 主机号(16位)  ]
		* 网络号字段有2字节，但前面两位（10）已经固定了，只剩下14位可以进行分配。
		* 可指派的网络数为 16383 ((1 << 14) - 1)，减 1 的原因是因为 B 类网络地址 128.0.0.0 是不指派的，可以指派的 B 类最小网络地址是 128.1.0.0 [COME06]​。

		* 该类地址每一个网络上的最大主机数是 65534 ((1 << 16) - 2)，减 2 是因为要扣除全 0 和全 1 的主机号。
		* 整个B类地址空间共约有 1073741824 (1 << 30)个地址，占整个IP地址空间的 25%。
		
	# C 类地址: [110	网络号(24位)	| 主机号( 8位)  ]
		* 网络号段占 3 个字节，还有 21 位(前三位固定了)可以进行分配，共 2097151 ((1 << 21) - 1) 个网络
		* 减 1 的原因是因为全 0 的C 类网络地址 192.0.0.0 ([11000000])也是不指派的，可以指派的C类最小网络地址是 192.0.1.0 [COME06]

		* 主机数占 1 个字节，最大主机数是 254 ((1 << 8) - 2) 个。整个 C 类地址空间共约有 536870912 (1 << 29)个地址，占整个IP地址的 12.5%。

	# D 类地址: [1110	网络号			| 多播地址		]
	# E 类地址: [1111	网络号			| 保留，今后使用]

	
	# 地址类别表

		A类：0xxxxxxx.host.host.host    (0.0.0.0 - 127.255.255.255)
		B类：10xxxxxx.net.host.host     (128.0.0.0 - 191.255.255.255)
		C类：110xxxxx.net.net.host      (192.0.0.0 - 223.255.255.255)

		网络类别	最大可指派的网络数		第一个可指派的网络号	最后一个可指派的网路号	每个网络中的最大主机数
		----------------------------------------------------------------------------------------------------------
		A			126((1 << 7) - 2)		1						126						16777214((1 << 24) - 2)
		B			16383((1 << 14) - 1)	128.1					191.255					65534((1 << 16) - 2)
		C			2097151((1 << 21) - 1)	192.0.1					223.255.255				254((1 << 8) - 2)
	
	#  一般不使用的特殊IP地址

		网络号	主机号				源地址使用	目标地址使用	代表的意思
		----------------------------------------------------------------------------------------------------------
		0		0					可以		不可以			在本网络上的本主机(HCP协议)
		0		host-id				可以		不可			在本网络上的某个主机 host-id
		全1		全1					不可		可以			只在本网络上进行广播(各路由器均不转发)
		net-id	全1					不可		可以			对net-id上的所有主机进行广播
		127		非全0或全1的任何数	可以		可以			用作本地软件环回测试之用
	

---------------------
ARP
---------------------
	# 地址解析协议 ARP
		* 根据机器（主机或路由器）的IP地址，找出其相应的硬件地址。

		* ARP 是解决同一个局域网上的主机或路由器的IP地址和硬件地址的映射问题。
		* 如果所要找的主机和源主机不在同一个局域网上，就无法解析出另一个局域网上主机的硬件地址
	
	# 每一个主机都设有一个ARP高速缓存(ARP cache)
		* 里面有本局域网上的各主机和路由器的IP地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。

		* 以主机 A 通过 IP 给主机 B 发消息来说
			1. 主机 A 的 ARP 表中存在主机 B 对应的硬件地址，直接把硬件地址写入 MAC 帧，通过局域网把该帧发往此地址。
			2. 主机 A 的 ARP 表中没有主机 B 对应的硬件地址，则发起 ARP 广播。
				2.1. 主机 A 向本局域网络中的所有机器广播发送 ARP 请求分组：“我的 IP 是 209.0.0.5，硬件地址是 00-00-C0-15-AD-18，我想要知道 IP 为 209.0.0.6 的硬件地址多少？”
				2.2. 收到 ARP 请求分组的机器检查自己的 IP 是否是 209.0.0.6
					2.2.1. 如果 IP 不是自己的，不管
					2.2.2. 如果 IP 是自己的，则给主机 A 单播  “我的IP地址是 209.0.0.6，我的硬件地址是 08-00-2B-00-EE-0A”
						2.2.2.1. 如果自己的 ARP 表中还没有对方的 IP 和硬件地址映射，则顺便在自己的 ARP 表中记下，“IP 209.0.0.5 的硬件地址是 00-00-C0-15-AD-18”。
			
		* ARP 把保存在高速缓存中的每一个映射地址项目都设置生存时间（例如，10～20分钟）​，凡超过生存时间的项目就从高速缓存中删除掉。
	
		
---------------------
IP 数据报
---------------------

	# IPv4 数据报
				
		0                   1                   2                   3   
		0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--------------------+----+
	   |Version|  IHL  |Type of Service|          Total Length         |					|	 |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+					|	 |
	   |         Identification        |Flags|      Fragment Offset    |					| 首 |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+					|	 |
	   |  Time to Live |    Protocol   |         Header Checksum       |	固定20字节		|	 |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+					|	 |
	   |                       Source Address                          |					|	 |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+					| 部 |
	   |                    Destination Address                        |					|	 |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--------------------+	 |
	   |                    Options                    |    Padding    |	可变长部分		|	 |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+--------------------+----+
	   |                    Data									   |
	   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

	   * IP数据报由首部和数据两部分组成，首部的前一部分是固定长度，共20字节，是所有IP数据报必须具有的。
	   
		
		Version 4 位
			* 版本号，指IP协议的版本。通信双方使用的IP协议的版本必须一致。目前广泛使用的IP协议版本号为 4 (即IPv4)
			* 目前最高为 6，即 IPV6
		
		IHL	4 位
			* 首部长度(Internet Header Length)，注意，所表示数的单位是 32 位字(1个32位字长是4字节)，即长度为多少个 4 字节。
			* 最大值是 15 (1111)，15 x 5 = 60 字节。
			* 最小值为  5 (0101)​，相当于IP首部长度为 5 x 4 = 20 字节。
		
			* 当IP分组的首部长度不是4字节的整数倍时，必须利用最后的填充字段加以填充。
		
		Type of Service	8 位
			* 区分服务，用来获得更好的服务。
			* 这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998年IETF把这个字段改名为区分服务 DS (Differentiated Services)。
			* 只有在使用区分服务时，这个字段才起作用​。在一般的情况下都不使用这个字段[RFC 2474, 3168, 3260]​。
		
		Total Length 16 位
			* 指首部和数据之和的长度，单位为字节。
			* 总长度字段为16位，因此数据报的最大长度为 2^16 - 1 = 65535 字节。

			* 然而实际上传送这样长的数据报在现实中是极少遇到的，需要考虑 MAC 帧的 MTU(1500 字节)
			* IP协议规定，因特网中所有的主机和路由器，必须能够接受长度不超过 576 字节的数据报。
			* 这是假定上层交下来的数据长度有 512 字节（合理的长度）​，加上最长的IP首部 60 字节，再加上4字节的富裕量，就得到576字节。
			* 当主机需要发送长度超过 576 字节的数据报时，应当先了解一下，目的主机能否接受所要发送的数据报长度。否则，就要进行分片。
		
		Identification 16 位
			* 标识，IP 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加 1，并将此值赋给标识字段。
			* 但这个 “标识” 并不是序号，因为IP是无连接服务，数据报不存在按序接收的问题。
			
			* 当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报片的标识字段中。
			* 相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报。
		
		Flags 3 位
			* 标志，目前只有两位有意义。
			* 最低位记为 MF (More Fragment)。MF = 1 即表示后面“还有分片”的数据报，MF = 0 表示这已是若干数据报片中的最后一个。
			* 标志字段中间的一位记为 DF (Do not Fragment)，意思是 “不能分片”​。只有当 DF = 0 时才允许分片。
		
		Fragment Offset 13 位
			* 片偏移，较长的分组在分片后，某片在原分组中的相对位置。
			* 也就是说，相对于用户数据字段的起点，该片从何处开始，片偏移以 8个字节为偏移单位。这就是说，每个分片的长度一定是 8 字节（64位）的整数倍。
			* 这片数据的开头，在原始数据中是第几个 8 字节？

		
			* 例如，报文和首部消息总大小为：3820
				1. 固定首部 20 字节，消息为 3800 字节，每个数据报片的数据部分长度不能超过 1400 字节。
				2. 于是可以拆成 3 个分片
		
								Range		Total Length	Flags		Fragment Offset
					第 1 片		0-1399		1400+20=1420	MF=1/DF=0	0/8=0
					第 2 片		1400-2799	1400+20=1420	MF=1/DF=0	1400/8=175
					第 3 片		2800-3799	1000+20=1020	MF=0/DF=1	2800/8=350
		
		
		Time to Live 8 位
			* 生存时间，表明是数据报在网络中的寿命。
			* 由发出数据报的源点设置这个字段，其目的是防止无法交付的数据报无限制地在因特网中兜圈子（例如从路由器R1转发到R2，再转发到R3，然后又转发到R1）​，因而白白消耗网络资源。
		
			* 最初的设计是以秒作为TTL值的单位
				* 每经过一个路由器时，就把TTL减去数据报在路由器所消耗掉的一段时间。
				* 若数据报在路由器消耗的时间小于 1 秒，就把TTL值减 1。
				* 当TTL值减为零时，就丢弃这个数据报。
			
			* 现在把 TTL 字段的功能改为“跳数限制”​（名称没变）
				* 指明数据报在因特网中至多可经过多少个路由器。​
				* 路由器在转发数据报之前就把TTL值减 1，若TTL值减小到零，就丢弃这个数据报，不再转发。

				* 显然，数据报能在因特网中经过的路由器的最大数值是 255。
				* 若把 TTL 的初始值设置为1，就表示这个数据报只能在本局域网中传送，因为这个数据报一传送到局域网上的某个路由器，在被转发之前TTL值就减小到零，因而就会被这个路由器丢弃。

		
		Protocol 8 位
			* 协议，指出此数据报携带的数据是使用何种协议，以便使目的主机的IP层知道应将数据部分上交给哪个处理过程。
			* 该字段的值为协议的编号，协议编号由 IANA 维护。

				协议名称	字段值		说明
				----------------------------------------------------
				ICMP		1
				IGMP		2
				IP			4			特殊的IP数据报——IP数据报再封装到IP数据报中。
				TCP			6
				EGP			8
				IGP			9
				UDP			17
				IPv6		41
				ESP			50
				OSPF		89
		
		Header Checksum 16 位
			* 首部校验和，这个字段只检验数据报的首部，但不包括数据部分。
			* 数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。
			* IP首部的检验和不采用复杂的CRC检验码而采用下面的简单计算方法(为了减小计算检验和的工作量)：

				1. 在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段置零。
				2. 用反码算术运算把所有16位字相加后，将得到的和的反码写入检验和字段。
				
				3. 接收方收到数据报后，将首部的所有16位字再使用反码算术运算相加一次。将得到的和取反码，即得出接收方检验和的计算结果。
				4. 若首部未发生任何变化，则此结果必为0，于是就保留这个数据报。否则即认为出差错，并将此数据报丢弃。
		
		
		Source Address 32 位
			* 源地址

		Destination Address  32 位
			* 目标地址
		

		Options 可变长度
			* 选项，用来支持排错、测量以及安全等措施，内容很丰富。
			* 长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。
			* 有些选项项目只需要1个字节，它只包括1个字节的选项代码。
			* 有些选项需要多个字节，这些选项一个个拼接起来，中间不需要有分隔符。
			* 最后用全0的填充字段补齐成为 4 字节的整数倍。

			* 这增加了每一个路由器处理数据报的开销，实际上这些选项很少被使用。
			* 很多路由器都不考虑IP首部的选项字段，因此新的IP版本IPv6就把IP数据报的首部长度做成固定的。


---------------------
IP 分组转发
---------------------
	# 按主机所在的网络地址来制作路由表
		* 在路由表中，对每一条路由最主要的是以下两个信息

			* 目的网络地址
			* 下一跳地址
	
	# 特定主机路由
		* 因特网所有的分组转发都是基于目的主机所在的网络，但在大多数情况下都允许有这样的特例，即对特定的目的主机指明一个路由。
		* 方便地控制网络和测试网络，以及在对网络的连接或路由表进行排错。
	

	# 默认路由
		* 可以减少路由表所占用的空间和搜索路由表所用的时间。
		* 这种转发方式在一个网络只有很少的对外连接时是很有用的。
	

	# 找到下一跳路由器
		* 当路由器收到一个待转发的数据报，在从路由表得出下一跳路由器的 IP 地址后，不是把这个地址填入IP数据报，而是送交数据链路层的网络接口软件。
		* 网络接口软件负责把下一跳路由器的 IP 地址转换成硬件地址（使用ARP）​，并将此硬件地址放在链路层的MAC帧的首部，然后根据这个硬件地址找到下一跳路由器。
		* 由此可见，当发送一连串的数据报时，上述的这种查找路由表、计算硬件地址、写入MAC帧的首部等过程，将不断地重复进行，造成了一定的开销。
	
	# 分组转发算法
		1. 从数据报的首部提取目的主机的IP地址D, 得出目的网络地址为 N。
		2. 若N就是与此路由器直接相连的某个网络地址，则进行直接交付，不需要再经过其他的路由器，直接把数据报交付目的主机（这里包括把目的主机地址 D 转换为具体的硬件地址，把数据报封装为MAC帧，再发送此帧）​；否则就是间接交付，执行(3)。
		3. 若路由表中有目的地址为D的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。
		4. 若路由表中有到达网络N的路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(5)。
		5. 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。
		6. 报告转发分组出错。
	

---------------------
子网划分
---------------------
	# 1985年起在IP地址中又增加了一个“子网号字段”​，使两级IP地址变成为三级IP地址
		* 这种做法叫作划分子网(subnetting) [RFC 950]​，或子网寻址或子网路由选择。
		* 划分子网已成为因特网的正式标准协议。
	
	# 子网
		* 一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个子网(subnet)，对外界来说是透明的。
		* 子网是从网络的主机号借用若干位作为子网号 subnet-id，当然主机号也就相应减少了同样的位数，于是两级IP地址在本单位内部就变为三级IP地址。
			IP 地址 = {<网络号>, <子网号>, <主机号>}
	
		* 从其他网络发送给单位的IP数据报，仍然是根据IP数据报的目的网络号找到连接在本单位网络上的路由器。
		* 但此路由器在收到IP数据报后，再按目的网络号和子网号找到目的子网，把IP数据报交付目的主机。
		
		* 划分子网只是把IP地址的主机号这部分进行再划分，而不改变IP地址原来的网络号。
		* 划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。
	
	
	# 子网掩码
		* 从IP数据报的首部无法看出源主机或目的主机所连接的网络是否进行了子网的划分(IP地址本身以及数据报的首部都没有包含任何有关子网划分的信息)。

		* 虽然RFC文档中没有规定子网掩码中的一串1必须是连续的，但却极力推荐在子网掩码中选用连续的1，以免出现可能发生的差错。

		* 现在因特网的标准规定：所有的网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。
		* 如果一个网络不划分子网，那么该网络的子网掩码就使用默认子网掩码，默认子网掩码中 1 的位置和 IP 地址中的网络号字段net-id正好相对应。

			A类：255.0.0.0        二进制：11111111.00000000.00000000.00000000
			B类：255.255.0.0      二进制：11111111.11111111.00000000.00000000
			C类：255.255.255.0    二进制：11111111.11111111.11111111.00000000


		* 因此，若用默认子网掩码和某个不划分子网的IP地址逐位相“与”(AND)，就应当能够得出该 IP 地址的网络地址来。这样做可以不用查找该地址的类别位就能知道这是哪一类的IP地址。
			
		* 路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。
		* 在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。


		* 虽然根据已成为因特网标准协议的RFC 950文档，子网号不能为全1或全0，但随着无分类域间路由选择CIDR的广泛使用（在4.3.3节讨论）​，现在全1和全0的子网号也可以使用了，但一定要谨慎使用，要弄清你的路由器所用的路由选择软件是否支持全0或全1的子网号这种较新的用法。


	
	# 根据子网掩码计算出 IP 所属的子网的网络地址
		
		IP & 子网掩码 = 子网的网络地址
		
		* 例如
			IP = 145.13.3.10	10010001.00001101.00000011.00001010
			mask = 0xFFFFFF00	11111111.11111111.11111111.00000000		255.255.255.0


			子网地址 = IP & mask;

		
		* Golang 例子
			// IP		145.13.3.10
			var ip = uint32(0b10010001_00001101_00000011_00001010)
			// 子网掩码	255.255.255.0
			var mask = uint32(0b11111111_11111111_11111111_00000000)

			// 计算出 IP 所属的子网地址
			var ret = ip & mask

			// 解析 10 进制的子网地址为字节数组
			var addr [4]byte
			binary.BigEndian.PutUint32(addr[:], ret)

			// 解析数组为 IP
			subNetAddr := net.IP(addr[:]).To4()
			
			// 145.13.3.0
			fmt.Println(subNetAddr)

					
---------------------
使用子网时分组的转发
---------------------
	# 路由表必须包含以下三项内容
		* 目的网络地址
		* 子网掩码
		* 下一跳地址
	
	# 路由器转发分组的算法如下
		1. 从收到的数据报的首部提取目的IP地址 D。
		2. 先判断是否为直接交付。
			* 对路由器直接相连的网络逐个进行检查：用各网络的子网掩码和 D 逐位相“与”​（AND操作）​，看结果是否和相应的网络地址匹配。

			* 若匹配，则把分组进行直接交付（当然还需要把 D 转换成物理地址，把数据报封装成帧发送出去）​，转发任务结束。
			* 否则就是间接交付，执行(3)。
		
		3. 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。
		4. 对路由表中的每一行（目的网络地址，子网掩码，下一跳地址）​，用其中的子网掩码和D逐位相“与”​（AND操作）​，其结果为 N。
			* 若 N 与该行的目的网络地址匹配，则把数据报传送给该行指明的下一跳路由器；
			* 否则，执行(5)。
		5. 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。
		6. 报告转发分组出错。

---------------------
分类编址CIDR（构成超网）
---------------------
	# 无分类编址方法，它的正式名字是无分类域间路由选择 CIDR (Classless Inter-Domain Routing，CIDR的读音是 “sider”)
		* CIDR 把 32 位的 IP 地址划分为两个部分。
			* 前面的部分是“网络前缀”(network-prefix)（或简称为“前缀”​）​，用来指明网络
			* 后面的部分则用来指明主机。
			
			* 因此CIDR使IP地址从三级编址（使用子网掩码）又回到了两级编址，但这已是无分类的两级编址。


				IP 地址 = {<网络前缀>, <主机号>}
			
			* CIDR 还使用“斜线记法”(slash notation)，或称为CIDR记法，即在IP地址后面加上斜线“/”​，然后写上网络前缀所占的位数。
			* CIDR 把网络前缀都相同的连续的IP地址组成一个“CIDR地址块”​。
				* 只要知道CIDR地址块中的任何一个地址，就可以知道这个地址块的起始地址（即最小地址）和最大地址，以及地址块中的地址数。

				128.14.35.7/20 = 10000000000011100010001100000111

					* 128.14.35.7 的二进制表示是 10000000000011100010001100000111
					* 20，则表示是前 20 位是网络前缀（用粗体和下画线表示出）​，而前缀后面的 12 位是主机号
				
					* 那么其最大、最小地址如下：
						10000000000011100010 000000000000		// 128.14.32.0
						10000000000011100010 111111111111		// 128.14.47.255
			
					* 共有  2 ^ 12 个地址，当然，这两个主机号是全0和全1的地址一般并不使用。通常只使用在这两个地址之间的地址。
					* 可以用地址块中的最小地址和网络前缀的位数指明这个地址块。
						128.14.32.0/20
				
					* 在不需要指出地址块的起始地址时，也可把这样的地址块简称为 “/20地址块”​。
			
		
		* CIDR使用32位的地址掩码(address mask)
			* 例如 “/20“ 地址块的地址掩码是：11111111 111111111111000000000000（20个连续的1）​。
			* 斜线记法中，斜线后面的数字就是地址掩码中1的个数。
		
		* 根据地址块，还可以快速计算出最大地址和最小地址
			
			192.199.170.82/27
				* 前 27 位是前缀，占用了 IP 的前 4 字节
				* 看 IP 地址中的第 4 个字节，就是 82
				* 82 的二进制为 01010010
				* 前面 3 位(010)保持不动，因为这 3 位属于前缀（3 x 8 + 3 = 27 位）
					
				* 最小值：剩下的位全部填充 0：01000000	= 64	=	192.199.170.64
				* 最大值：剩下的位全部填充 1：01011111	= 95	=	192.199.170.95
		
		* 可以把点分十进制中低位连续的 0 省略：地址块 10.0.0.0/10 可简写为 10/10
		* 还有一种前缀表示法：在网络前缀的后面加一个星号 *，如：0000101000* 意思是：在星号* 之前是网络前缀，而星号*表示IP地址中的主机号，可以是任意值。
		* 前缀位数不是8的整数倍时，需要进行简单的计算才能得到一些地址信息。
			
	# 构成超网(supernetting)
		

				

---------------------
ICMP
---------------------
	# 网际控制报文协议ICMP (Internet Control Message Protocol) [RFC 792]​。
		* 为了更有效地转发IP数据报和提高交付成功的机会，网际层使用了该协议

		* ICMP是因特网的标准协议，它封装在 IP 报文中（数据部分）。
		* 但 ICMP 不是高层协议，而是IP层的协议。
	

	# 协议

		0                   1                   2                   3
		0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		|     Type      |     Code      |          Checksum             |
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		|               (取决于 ICMP 报文类型)                          |
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		|			ICMP 数据，长度取决于类型							|
		+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		
		* CMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。
		* 接着的 4 个字节的内容与ICMP的类型有关（基本上没用）。
		* 最后面是数据字段，其长度取决于ICMP的类型




		Type
			* 类型，1个字节
			* 几种常用的 ICMP 报文类型和值如下

				* 差错报告报文
					3	终点不可达
					4	源点抑制(Source Quench)
					11	时间超过
					12	参数问题
					5	改变路由(重定向)
				
				* 询问报文
					8 或 0		回送(Echo)请求或回答
					13 或 14	时间戳(Timestamp)请求或回答
				
		Code
			* 代码，1 个字节
			* 为了进一步区分某种类型中的几种不同的情况。

			

		Checksum
			* 校验和，2 字节
			* 用来检验整个ICMP报文。
	
	# ICMP 差错报告报文共有五种

		1. 终点不可达 当路由器或主机不能交付数据报时就向源点发送终点不可达报文。
		2. 源点抑制 当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文，使源点知道应当把数据报的发送速率放慢。
		3. 时间超过 当路由器收到生存时间为零的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。
			* 当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。
		4. 参数问题 当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。
		5. 改变路由（重定向） 路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器（可通过更好的路由）​。
	
	
	# 差错报告报文
		* 所有的ICMP差错报告报文中的数据字段都具有同样的格式
		* 把收到的需要进行差错报告的IP数据报的首部和数据字段的前8个字节提取出来，作为ICMP报文的数据字段。再加上相应的ICMP差错报告报文的前8个字节，就构成了ICMP差错报告报文。
		* 提取收到的数据报的数据字段的前8个字节是为了得到运输层的端口号（对于TCP和UDP）以及运输层报文的发送序号（对于TCP）​。
		* 这些信息对源点通知高层协议是有用的​
		* 整个ICMP报文作为IP数据报的数据字段发送给源点。


							+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+------------------------------------+
							|     Type      |     Code      |          Checksum             |									 |
							+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	ICMP差错报告报文的前8个字节		 |
							|				(取决于 ICMP 报文类型)   						|									 |
							+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+------------------------------------+
							|			IP 数据报首部  + IP 数据报数据字段的前 8 个字节		|
				+-----------+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
				|IP  Header |			IP 数据报数据										|
				+-----------+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
		
		* 不应发送ICMP差错报告报文的几种情况。
			
			1. 对ICMP差错报告报文不再发送ICMP差错报告报文。
			2. 对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。
			3. 对具有多播地址的数据报都不发送ICMP差错报告报文。
			4. 对具有特殊地址（如127.0.0.0或0.0.0.0）的数据报不发送ICMP差错报告报文。
		
	# ICMP询问报文有两种
		
		1. 回送请求和回答 ICMP回送请求报文是由主机或路由器向一个特定的目的主机发出的询问。
			* 收到此报文的主机必须给源主机或路由器发送ICMP回送回答报文。
			* 这种询问报文用来测试目的站是否可达以及了解其有关状态。
		
		2. 时间戳请求和回答 ICMP时间戳请求报文是请某个主机或路由器回答当前的日期和时间。
			* 在ICMP时间戳回答报文中有一个32位的字段，其中写入的整数代表从1900年1月1日起到当前时刻一共有多少秒。
			* 时间戳请求与回答可用来进行时钟同步和测量时间。
	

	# 分组网间探测 PING (Packet InterNet Groper)

		* PING使用了ICMP回送请求与回送回答报文。PING是应用层直接使用网络层ICMP的一个例子。
		* 它没有通过运输层的TCP或UDP。

			正在 Ping springboot.io [8.217.138.140] 具有 32 字节的数据:
			来自 8.217.138.140 的回复: 字节=32 时间=129ms TTL=50
			来自 8.217.138.140 的回复: 字节=32 时间=131ms TTL=50
			来自 8.217.138.140 的回复: 字节=32 时间=129ms TTL=50
			来自 8.217.138.140 的回复: 字节=32 时间=130ms TTL=50

			8.217.138.140 的 Ping 统计信息:
				数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，
			往返行程的估计时间(以毫秒为单位):
				最短 = 129ms，最长 = 131ms，平均 = 129ms
			

			
	# 路由追踪
		* 跟踪一个分组从源点到终点的路径。
			* 在Windows操作系统中这个命令是 tracert
			* 在 UNIX 中值： traceroute
		
			tracert springboot.io

			通过最多 30 个跃点跟踪
			到 springboot.io [8.217.138.140] 的路由:

			  1     2 ms     1 ms     1 ms  iStoreOS.lan [192.168.0.1]
			  2     *        4 ms     5 ms  113.249.22.193
			  3     *        *        *     请求超时。
			  4    29 ms     9 ms     4 ms  222.182.217.170
			  5     *       12 ms     *     222.176.6.121
			  6     *        *        *     请求超时。
			  7     *        *        *     请求超时。
			  8     *       39 ms    39 ms  202.97.39.173
			  9    49 ms    47 ms    47 ms  202.97.116.46
			 10     *        *        *     请求超时。
			 11     *        *        *     请求超时。
			 12     *        *        *     请求超时。
			 13     *        *        *     请求超时。
			 14     *        *        *     请求超时。
			 15   131 ms   123 ms   128 ms  8.217.138.140

			跟踪完成。
		
		* 原理
			1. 从源主机向目的主机发送一连串的IP数据报，数据报中封装的是无法交付的UDP用户数据报（非法的端口）。
			2. 第一个数据报P1的生存时间TTL设置为1。当P1到达路径上的第一个路由器R1时，路由器R1先收下它，接着把TTL的值减1。
				* 由于TTL等于零了，R1就把P1丢弃了，并向源主机发送一个ICMP时间超过差错报告报文。
			2. 源主机接着发送第二个数据报P2，并把TTL设置为2。P2先到达路由器R1，R1收下后把TTL减1再转发给路由器R2。
				* R2收到P2时TTL为1，但减1后TTL变为零了。R2就丢弃P2，并向源主机发送一个ICMP 时间超过差错报告报文。
				* 这样一直继续下去。当最后一个数据报刚刚到达目的主机时，数据报的TTL是1。
			3. 主机不转发数据报，也不把TTL值减1。
				* 但因IP数据报中封装的是无法交付的运输层的UDP用户数据报，因此目的主机要向源主机发送ICMP终点不可达差错报告报文
			4. 经过上述步骤，源主机达到了自己的目的，因为这些路由器和最后目的主机发来的ICMP报文正好给出了源主机想知道的路由信息
				* 到达目的主机所经过的路由器的IP地址，以及到达其中的每一个路由器的往返时间。
			
---------------------
路由选择协议
---------------------
	# 从路由算法能否随网络的通信量或拓扑自适应地进行调整变化来划分，则只有两大类
		1. 静态路由选择策略与
			* 静态路由选择也叫做非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。
			* 对于很简单的小网络，完全可以采用静态路由选择，用人工配置每一条路由
		
		2. 动态路由选择策略
			* 也叫做自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大
			* 因此，动态路由选择适用于较复杂的大网络。
			* 因特网采用的就是这个

	
	# 分层次的路由选择协议
		
		* 因特网采用分层次的路由选择协议
		* 因特网将整个互联网划分为许多较小的自治系统(autonomous system)，一般都记为 AS。

	
	# 在目前的因特网中，一个大的ISP就是一个自治系统。
		* 这样，因特网就把路由选择协议划分为两大类。

		* 内部网关协议 IGP (Interior Gateway Protocol)
			* 即在一个自治系统内部使用的路由选择协议，而这与在互联网中的其他自治系统选用什么路由选择协议无关。
			* 目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。

		* 外部网关协议 EGP (External Gateway Protocol)
			* 若源主机和目的主机处在不同的自治系统中（这两个自治系统可能使用不同的内部网关协议）​，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。这样的协议就是外部网关协议EGP。
			* 目前使用最多的外部网关协议是 BGP 的版本4（BGP-4）​。
	

		* 自治系统之间的路由选择也叫做域间路由选择(interdomain routing)，而在自治系统内部的路由选择叫做域内路由选择(intradomain routing)。
		* 以前没 “路由器” 这个词，都叫做网关 “Gateway”，现在有些文档开始用路由器了（Router），因此也把原来的 IGP 和 EGP 分别改为IRP（内部路由器协议）和ERP（外部路由器协议）
	
	# RIP 协议
		* 路由信息协议 RIP (Routing Information Protocol)
			* 是内部网关协议IGP中最先得到广泛使用的协议[RFC 1058]​
			* 是一种分布式的基于距离向量的路由选择协议，是因特网的标准协议，其最大优点就是简单。
			* RIP允许一条路径最多只能包含15个路由器（跳）。因此“距离”等于16时即相当于不可达。可见 RIP只适用于小型互联网。

			* RIP协议让一个自治系统中的所有路由器都和自己的相邻路由器定期交换路由信息，并不断更新其路由表，使得从每一个路由器到每一个目的网络的路由都是最短的（即跳数最少）​。
		
		* 特点
			* 仅和相邻的几个路由器（不是所有）交换信息。
			* 交换的信息是当前本路由器所知道的全部信息，即自己的路由表。
		
		* RIP协议使用距离向量算法
			
			1. 首先，每个 RIP 包中有多个项目，每个项目包含了3个东西：
				* 网络
				* 距离（到网络的跳数）
				* 下一跳地址
			
			2. 收到地址为 Y 的邻居路由器发来的 RIP 包，遍历每个项目
				1. 把每个项目的 “下一跳” 都改成 “Y”
				2. 把每个项目的 “距离” + 1
			
			3. 遍历修改后的每个项目，和自己的路由表进行对比
				1. 自己路由表没有项目中的网络，新增
				2. 自己路由表存在这个网络，则查看下一跳的地址
					1. 下一跳的地址就是 Y（没变），更新，这是最新的路由
					2. 下一跳的地址不是 Y，比较距离
						1. 如果收到的项目的距离，比已存在的小，则更新
						2. 如果收到的项目的距离，比已存在的大，则不更新
			
			4. 若3分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达的路由器，即把距离置为16（距离为16表示不可达）​。
				

		* 报文格式

			* Header 首部，共 4 个字节
				0                   1                   2                   3
				0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
			   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
			   |  command (1)  |  version (1)  |       must be zero (2)        |
			   +---------------+---------------+-------------------------------+
			   |                                                               |
			   ~                         RIP Entry (20)                        ~
			   |                                                               |
			   +---------------+---------------+---------------+---------------+
				
				command
					* 命令，1个字节，表示报文的意义
						1	表示请求路由信息。
						2	表示对请求路由信息的响应或未被请求而发出的路由更新报文。

				version
					* 版本号，1个字节

				剩下的
					* 必须全部为 0，目的是和 4 字节对齐

				Entry
					* 即，路由信息，有多个。
					* 一个RIP报文最多可包括 25 个路由，因而RIP报文的最大长度是 4 + 20×25 = 504 字节。如超过，必须再用一个RIP报文来传送。
			
			* Entry
			
				0                   1                   2                   3 3
				0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
			   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
			   | Address Family Identifier (2) |        Route Tag (2)          |
			   +-------------------------------+-------------------------------+
			   |                         IP Address (4)                        |
			   +---------------------------------------------------------------+
			   |                         Subnet Mask (4)                       |
			   +---------------------------------------------------------------+
			   |                         Next Hop (4)                          |
			   +---------------------------------------------------------------+
			   |                         Metric (4)                            |
			   +---------------------------------------------------------------+

				* 路由信息，每个路由信息需要用20个字节。

				* Address Family Identifier
					* 地址族标识符（又称为地址类别）字段用来标志所使用的地址协议。
					* 如采用 IP 地址就令这个字段的值为 2（原来考虑 RIP 也可用于其他非 TCP/IP 协议的情况）​。
				
				* Route Tag
					* 路由标记填入自治系统号ASN (Autonomous System Number)，这是考虑使RIP有可能收到本自治系统以外的路由选择信息。
				
				* IP Address，网络地址
				* Subnet Mask，该网络的子网掩码
				* Next Hop，下一跳路由器地址
				* Metric，到此网络的距离。
				

			* RIP 协议使用运输层的用户数据报 UDP 进行传送（使用UDP的端口520）。
			* RIP2还具有简单的鉴别功能
				* 若使用鉴别功能，则将原来写入第一个路由信息（20字节）的位置用作鉴别。
				* 这时应将地址族标识符置为全1（即0xFFFF）​，而路由标记写入鉴别类型，剩下的16字节为鉴别数据。
				* 在鉴别数据之后才写入路由信息，但这时最多只能再放入24个路由信息。
			

	# OSPF 协议
		* 开放最短路径优先 OSPF (Open Shortest Path First)。它是为克服RIP的缺点在1989年开发出来的。
		* “最短路径优先” 是因为使用了 Dijkstra 提出的最短路径算法 SPF​。OSPF 的第二个版本 OSPF2 已成为因特网标准协议[RFC 2328]​。
		

		* 使用分布式的链路状态协议(link state protocol)
			1. 向本自治系统中所有路由器发送信息（洪泛法），路由器通过所有输出端口向所有相邻的路由器发送信息。
				* 而每一个相邻路由器又再将此信息发往其所有的相邻路由器（但不再发送给刚刚发来信息的那个路由器。
			
			2. 发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。
				* 所谓 “链路状态”就是说明本路由器都和哪些路由器相邻[插图]，以及该链路的“度量”(metric)”，也可以叫做代价。
				* OSPF 将这个“度量”用来表示费用、距离、时延、带宽，等等。
			
			3. 只有当链路状态发生变化时，路由器才向所有路由器用洪泛法发送此信息。
				* 而不像RIP那样，不管网络拓扑有无发生变化，路由器之间都要定期交换路由表的信息。

		* 协议格式
			
			* Header，24 字节

				0                   1                   2                   3
				0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
			   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
			   |   Version #   |     Type      |         Packet length         |
			   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
			   |                          Router ID                            |
			   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
			   |                           Area ID                             |
			   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
			   |           Checksum            |             AuType            |
			   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
			   |                       Authentication                          |
			   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
			   |                       Authentication                          |
			   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
					
				* Version 1 字节
					版本 当前的版本号是 2。
				
				* Type 1 字节
					*  类型，可以是五种类型分组中的一种。
				
				* Packet length 2 字节
					* 分组长度，包括 OSPF 首部在内的分组长度，以字节为单位。
				
				* Router ID 4 字节
					路由器标识符 标志发送该分组的路由器的接口的IP地址。
				
				* Area ID 4 字节
					区域标识符 分组属于的区域的标识符。
				
				* Checksum 2 字节
					检验和 用来检测分组中的差错。
				
				* AuType 2 字节
					鉴别类型 目前只有两种。0（不用）和1（口令）​。
				
				* Authentication 8 字节
					鉴别 鉴别类型为0时就填入0。鉴别类型为1则填入8个字符的口令。
			
			* Body
				

		
		   * OSPF不用UDP而是直接用IP数据报传送(其IP数据报首部的协议字段值为89)。
		   * OSPF的五种分组类型
				1. 问候(Hello)分组，用来发现和维持邻站的可达性。
				2. 数据库描述(Database Description)分组，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。
				3. 链路状态请求(Link State Request)分组，向对方请求发送某些链路状态项目的详细信息。
				4. 链路状态更新(Link State Update)分组，用洪泛法对全网更新链路状态。这种分组是最复杂的，也是OSPF协议最核心的部分。
					* 路由器使用这种分组将其链路状态通知给邻站。链路状态更新分组共有五种不同的链路状态[RFC 2328]​，这里从略。
				5. 链路状态确认(Link State Acknowledgment)分组，对链路更新分组的确认。
			
	
	# BGP 协议
		* 1989年，公布了新的外部网关协议——边界网关协议 BGP。


--------------------------
IP 多播
--------------------------
		

--------------------------
VPN 和 NAT
--------------------------
	# 本地地址
		* 仅在机构内部使用的计算机就可以由本机构自行分配其IP地址。
		* 这就是说，让这些计算机使用仅在本机构有效的IP地址（这种地址称为本地地址）​，而不需要向因特网的管理机构申请全球唯一的IP地址（这种地址称为全球地址）。

		* RFC 1918指明了一些专用地址(private address)。这些地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信。

		* 在因特网中的所有路由器，对目的地址是专用地址的数据报一律不进行转发。

		* 2010年1月，RFC 5735全面地给出了所有特殊用途的IPv4地址，但三个专用地址块的指派并无变化，即：

			1. 10.0.0.0 到 10.255.255.255 （或记为10.0.0.0/8，它又称为24位块）
			2. 172.16.0.0 到 172.31.255.255 （或记为172.16.0.0/12，它又称为20位块）
			3. 192.168.0.0 到 192.168.255.255 （或记为192.168.0.0/16，它又称为16位块）
		
	
	# 虚拟专用网 VPN (Virtual Private Network)
		* 利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网即 虚拟专用网 VPN (Virtual Private Network)。
		* 如果专用网不同网点之间的通信必须经过公用的因特网，但又有保密的要求，那么所有通过因特网传送的数据都必须加密。
		* 一个机构要构建自己的VPN就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的VPN系统都知道其他场所的地址。

	
	# 网络地址转换 NAT (Network Address Translation)
		* 这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。
		* 这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。
		* 当NAT路由器具有n个全球IP地址时，专用网内最多可以同时有n个主机接入到因特网。这样就可以使专用网内较多数量的主机，轮流使用NAT路由器有限数量的全球IP地址。

		* 专用网内部的主机不能充当服务器用，因为因特网上的客户无法请求专用网内的服务器提供服务。
	
	# 网络地址与端口号转换 NAPT (Network Address and Port Translation)
		* 为了更加有效地利用 NAT 路由器上的全球IP地址，现在常用的NAT转换表把运输层的端口号也利用上。
		* 这样，就可以使多个拥有本地地址的主机，共用一个 NAT 路由器上的全球 IP 地址，因而可以同时和因特网上的不同主机进行通信。

	





		


