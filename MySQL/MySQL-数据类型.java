-----------------------
MySQL-整数类型			|
-----------------------
	# 数据类型,也就是传说中的列类型.就是对数据进行统一的分类.
	# SQL中把数据分为了三大类
		1,数值类型
		2,字符串类型
		3,日期功能
	
	
----------------------
MYSQL-数值类型-整数		|
----------------------
	tinyint
		# 迷你整形
		# 1字节		
		# 256 最大值
		
	smallint
		# 小整形	
		# 2字节		
		# 65536 最大值
		
	mediumint
		# 中整形
		# 3个字节
		
	int	['常用']
		# 标准类型
		# 使用4个字节存储
		
	bigint
		# 大整形
		
	# 无符号约束
		* unsigned
		* QL中的数值类型全部都是默认有符号:分正负
		* 有时候需要使用无符号数据,就需要给字段添加'无符号约束'
		* 使用无符号约束后,会多出来一个位置,可以多存放一个数值
		* age int unsigned,

	# 显示宽度约束
		* 数据,最终显示的最大位数(包括符号)
		* -123:四位显示,123:三位显示
		* 这种约束不会改变数值本身的大小.数值大小始终是由列类型控制
		* 该约束,的意义:当数据不够指定宽度的时候,自动让数据变成对应的显示宽度
		* 通常需要搭配一个'前导零'配置
		* age int(2) zerofill
			* 显示宽度为2,不足的话,添0补充
			* 一旦使用'zerofill,就会默认的设置无符号约束'.

		
----------------------
MYSQL-数值类型-小数		|
----------------------
	# 小数形:带有小数点,或者范围超出整形的数据
	# 为了保证精度,MYSQL把小数分为两种类型
		1,浮点型
			* 小数点浮动,精度有限.会丢失精度
			* '超出范围,四舍五入处理'
		2,定点型
			* 小数点固定,精度固定,不会丢失精度
		'浮点形数据的插入,整数部分是不能超出长度的,但是小数部分可以超出(自动的四舍五入)'
		'如果是因为舍入机制,而导致,整数部分超出长度.那么系统是允许的'
											
	float
		# 单精度,占用4个字节
	double
		# 双精度,占用8个字节
	decimal
		# 定点形,绝对的保证.整数部分不会被丢失精度(也就是不会被四舍五入)
		# 理论上,小数部分也不会丢失精度
		# 这东西没有固定的长度,是根据数据的长度.来自动的调整
		# '定点数的整数部分,一定不能超出长度(进位也不可以)'

	# 创建浮点数字段
		slary float(M,D)
		* M:该值表示总长度
		* D:代表小数部分的长度
		(整数部分长度为:M-D)

	# 插入的数据可以是直接的小数,也可以是科学计数法
		* 99999
		* 3e38
-----------------------
MySQL-日期时间类型		|
-----------------------
	year
		# 年份,有两种表现形式
		# year(2)		
	timestamp
		# 时间戳,但是并不是时间戳!
		# 从1970年开始的,格式与datetime完全一直
		# 有很多的特性
			1,不能为空.
			2,可以自动跟随数据更新而更新
	time
		# 时间段,指定某个区间之间, -时间  + 时间
		# 表示的时间,可以是负数
	date
		# 就是datetime中间的日期部分
	datetime
		# 2016-06-04 13:29:08
		# 范围:1000 - 9999 年
		# 有0值:0000-00-00 00:00:00
	
	# 时间格式化函数
		DATE_FORMAT(createdate,'%Y-%m-%d %H:%i:%s') createdate
	

	# 关于时间戳类型
		* MYSQL 中的时间戳类型，默认精确到秒，可以调整到精确到秒后 6 位，即（微秒）
			`create_time` timestamp(6) NULL DEFAULT NULL COMMENT '创建时间'
		
		* 四舍五入的问题，默认情况下，如果插入的时间戳数据精度超出了设定，则会进行四舍五入
			
			// c3 列为时间戳列，最多只精确到秒后的 2 位
			// 插入 c3 时间戳为：2018-09-08 17:51:04.777 ，该值精确到了秒后 3 位
			CREATE TABLE fractest( c1 TIME(2), c2 DATETIME(2), c3 TIMESTAMP(2) );
			INSERT INTO fractest VALUES('17:51:04.777', '2018-09-08 17:51:04.777', '2018-09-08 17:51:04.777');
			
			// 读取
			// c3 列只保存了 2 位（即设置的最大精度），而且对超出的部分进行了四舍五入。
			// 2018-09-08 17:51:04.777 -> 四舍五入 -> 2018-09-08 17:51:04.78
			mysql> SELECT * FROM fractest;
			+-------------+------------------------+------------------------+
			| c1          | c2                     | c3                     |
			+-------------+------------------------+------------------------+
			| 17:51:04.78 | 2018-09-08 17:51:04.78 | 2018-09-08 17:51:04.78 |
			+-------------+------------------------+------------------------+
		
		* 四舍五入可能会带有精度问题，可以修改配置，强制截断超出精度后的数据
			
			// 临时配置
			SET @@sql_mode = sys.list_add(@@sql_mode, 'TIME_TRUNCATE_FRACTIONAL');
			
			// 全局配置
			[mysqld]
			sql-mode=TIME_TRUNCATE_FRACTIONAL
	
		* 修改时间戳的时区
			-- 修改时区为东八区
			CONVERT_TZ(t.create_time, '+00:00', '+08:00')
			-- 格式化后修改的时区
			DATE_FORMAT(CONVERT_TZ(t.create_time, '+00:00', '+08:00'), '%Y-%m-%d')

	# 建议使用 bitint 来代替 timestamp 以避免 2038 问题
		
		* 把 bigint 转换为时间戳（注意，MYSQL 存储的是秒，所以，如果存储的是毫秒，则需要 / 1000）
			FROM_UNIXTIME( create_time / 1000 )


		* 对转换后的时间戳进行时区转换
			CONVERT_TZ( FROM_UNIXTIME(create_time / 1000 ), '+00:00', '+08:00' ) 
				
				* 第一个参数：'+00:00' 表示数据的原时区，是 UTC
				* 第二个参数：'+08:00' 表示要转换到的目标时区
		
		* 获取年月日时分秒信息
			DATE(FROM_UNIXTIME(create_time / 1000)) 
			TIME(FROM_UNIXTIME(create_time / 1000)) 

			* 单独获取某个字段

				YEAR (FROM_UNIXTIME(t.create_time / 1000 ))
				MONTH()
				DAY()
				HOUR()
				MINUTE()
				SECOND()

-----------------------
MySQL-字符串类型		|
-----------------------
	char
		# 定长字符串,就是在创建的时候.必须要指定其长度.数据必须≤该长度
		# char(L):L代表长度值,最大值为255
		# char(4)在UTF8编码格式下.需要:4 * 3 = 12个字节
		# 磁盘空间比较浪费,但是效率高
		# 身份证,电话号码,手机号码... ...
	varchar
		# 变长字符串,在分配空间的时候.按照最大的空间分配!如果数据超出,会自动增长!
		# vachar(L):L表达长度,理论长度是: 65536 个字符,但是实际上会多出1到2个字节来确定存储的实际长度
		# 磁盘空间比较节省,但是效率不高
		# 名字,文章,描述.... ...
	text
		# 如果说数据量大,超过了255个字符.那么就会使用到文本字符串
		# 不占用记录长度('但是本身占据10个字节')
	blob
		# 存数二进制数据、
	enum
		# 枚举,学过 JAVA就懂
		# 1 - 2 个字节
		# gender enum('男','女','保密'),	:那么该字段的值仅能是中间定义的数据值
		# 原理:在进行数据规范的时候,会自动建立一个数字与枚举的对应关系(Map),存放在日志中.然后再进行数据插入的时候.系统会把字段的字符,转换为对应的数字来进行存储.在提出数据的时候.又根据数字找到数据.返回
		# 根据上面所述,所以.'枚举可以直接插入值所对应的数字'
		# smail enum('哈哈','呵呵','嗯嗯'),
	set
		# 集合其实跟枚举很类型
		# 实际存储的数值,而不是字符串(集合是多选)
		# 可以使用元素列表中的元素,使用逗号','号隔开.
		# 集合中的每一个元素都是对应一个二进制位
	# null -- 占据一个字节
-----------------------
MySQL-列属性			|
-----------------------
	空属性
		# null(默认)
		# not null
	列描述
		# comment
			* 没有实际的含义,专门用来描述字段.会根据创建语句保存
			* id varchar(50) comment '主键'
	默认值
		# default
			* default [值]
			* 执行插入的时候,可以直接使用'default'关键字,来代替字段值
	无符号
		# unsigned
			* 用于数值,没有符号
	
-----------------------
MySQL-记录长度			|
-----------------------
	# MYSQL中规定,任何一条记录最长不能超过:65535 个字节.
						

-----------------------
数据转换				|
-----------------------
	# 字符串转为数字类型
		(t.money+0) money,
			//原来money是varchar,+0后就变成了字符串.... ...然后就可以进行排序操作了
	




-----------------------
一些知识				|
-----------------------
MYSQL的记录长度:65535个字节
varchar	:达不到理论长度
null	:本身要占用一个字节
text	:不占用记录长度(本身占据10个字节)