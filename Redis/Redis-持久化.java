-----------------------
Redis-快照持久化		|
-----------------------
	* redis为了内部数据的安全考虑,会把本身的数据以"文件"的形式保存到硬盘中
	  当服务再次启动的时候,又会读会内存.保存到硬盘的这个过程就叫做持久化
	
-----------------------
Redis-snapshotting持久化|
-----------------------
	# 'RDB'持久化
	* 这种持久化默认开启,一次性把redis中全部的数据都保存一份,存在硬盘中
	* 如果数据非常多(10-20GB),就'不适合频繁该持久化操作'
	* 在redis.cnf文件中
		save 900 1			//900秒,有超过1个key的数据被修改的话,我就发起一次快照保存
		save 300 10			//300秒,有超过10个Key的数据被修改的话,我就发起一次快照保存
		save 60 10000		//60秒内,有超过10000key的数据被修改的话,我就发起一次快照保存
		dbfilename dump.rdb	//快照持久化文件的名字,默认值:dump.rdb
		dir ./				//文件存储位置(linux系统,./当前目录下)
	
	* 以上条件都是  | 的关系.只要是满足其中一个,就会执行快照

	* 其实上面这三个设置的意思:
		数据修改的频率高,备份的频率也高
		数据修改的频率低,备份的频率也低

	* 快照持久化,持久化的是文件的名字和存储的位置
	
	* Redis启动后,会读取RDB文件,把数据从硬盘写入内存.据吹牛逼说.1GB数据,读取到内存需要20-30秒.当然,不同的服务器肯定是有差异的
	
	* RDB的快照过程
		1,Redis使用fork函数,复制一份当前的进程(父进程)的副本(子进程)
		2,父进程继续接收客户端发来的命令,而子进程开始把把内存中的数据写如到硬盘
		3,当子进程写完所有数据库后,会用该临时文件替换旧的RDB文件

	* RDB文件是通过压缩的(默认开启压缩),可以通过配置 rdbcompression 参数来禁止压缩
		rdbcompression yes/no
		* 压缩消耗性能,但是降低磁盘空间
		* 不压缩较占用磁盘空间
	
	* 在SAVE命令执行期间，Redis服务器将阻塞，直到RDB文件创建完毕为止。
	* BGSAVE不会直接使用Redis服务器进程创建RDB文件，而是使用子进程创建RDB文件。
		* RDB文件创建完毕之后，子进程退出并通知Redis服务器进程（父进程）新RDB文件已经完成。

-----------------------
Redis-appendonlyfile持久化|
-----------------------
	* 'AOF持久化'
	* 本质:把用户执行的每个"写指令"(添加,修改,删除)保存到文件中,还原的时候,就是仅仅执行了指定的语句而已
	* 说白了,日志.Redis启动的时候,会执行AOF文件,达到数据恢复的效果

	* 开启AOF持久化
		* 会清空redis内部的数据,所以安装的时候就建议开启

		* 在redis.conf配置文件中
			appendonly no					//改为yes即可

			appendfilename appendonly.aof	//持久化文件的名称

	* 配置文件被修改,需要删除旧进程,在根据配置文件重启新的进程

	* AOF追加持久化的备份频率

		appendfsync always		//有一个写入指令我就备份一次
			* 性能最差,但是可以保证数据
		appendfsync everysec	//每秒备份(记录操作命令)一次(推荐)
			* 性能和数据做了折中
		appendfsync no			//服务器心情好,就给你备份.心情不好,就等着晚点做!(其实就是根据性能来)
			* 性能最好,但是数据没保证

	* 为AOF备份文件做优化处理
		redis-cli bgrewriteaof
			* 这个命令其实就是把备份文件内容进优化压缩，该命令是一个无参数命令：
			* 例如:多个incr指令变成了一个set指令
		
		重写策略的参数设置
			auto-aof-rewrite-percentage 100
				* 当AOF文件大小超过上次重写的AOF文件大小的百分之多少时会再次进行重写.如果之前没有重写过.则以启动时的AOF文件大小为依据
			
			auto-aof-rewrite-min-size 64mb
				* 限制了允许重写的最小的AOF文件大小
				* 通常在AOF文件很小的时候即使其中有些冗余的命令也是可以忽略的
			

	* 快照持久化跟AOF持久化是一个互补关系
	* 快照持久化做大的文件备份
	* AOF做细致的文件备份
	* 还原的时候,一起还原

	*  aof-use-rdb-preamble yes
		* RDB-AOF混合持久化模式，这种模式是基于AOF持久化模式构建而来的――如果用户打开了服务器的AOF持久化功能，并且将这个值设置为了 yes
		* 那么Redis服务器在执行 AOF 重写操作时，就会像执行BGSAVE命令那样，根据数据库当前的状态生成出相应的RDB数据，并将这些数据写入新建的AOF文件中，至于那些在AOF重写开始之后执行的Redis命令，则会继续以协议文本的方式追加到新AOF文件的末尾，即已有的RDB数据的后面。

		* 换句话说，在开启了RDB-AOF混合持久化功能之后，服务器生成的AOF文件将由两个部分组成，其中位于AOF文件开头的是RDB格式的数据，而跟在RDB数据后面的则是AOF格式的数据


-----------------------------
手动发起快照				 |
-----------------------------
		redis-cli -h 192.168.0 -p 6379 bgsave
			* 这是对远程的服务器,发起快照持久化操作

		redis-cli bgsave
			* 这是对本地的redis服务,发起快照持久化操作

		redis-cli lastsave
			* 返回上次成功保存到磁盘的unix时间戳

		redis-cli shutdown
			* 同步保存到服务器,并且关闭redis服务器

		redis-cli bgrewriteaof
			* 当日志文件过长时,优化AOF日志文件存储
		

		* 可以通过save和bgsave命令来手动快照,两个命令的区别是,前者是由主进程进行快照.会阻塞其他的请求.候着是fork子进程进行快照操作
	
		'注意:'由于redis,使用 fork 来复制一份当前进程,那么子进程就会占有和主进程一样的内存资源.例如:主进程8GB内存,那么在备份的时候,就必须要保证有16GB的内存.要不然就会启用虚拟内存,性能较差

		