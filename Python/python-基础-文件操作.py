----------------------------
Python-文件操作				|
----------------------------
	open(file, mode, buffering, encoding, errors, newline, closefd, opener)
		* 全局函数,用于打开一个文件,如果文件不存在,抛出异常
		* 返回一个对象:<class '_io.TextIOWrapper'>/<class '_io.BufferedWriter'>
		* 第一个参数,以字符形式表示文件路径,可以是绝对路径,也可以是相对路径
		* 第二个参数,以字符形式表示打开文件的模式,枚举值
			r	
				* 以只读方式打开文件.文件的指针将会放在文件的开头.这是默认模式.
			w	
				* 打开一个文件只用于写入.如果该文件已存在则将其覆盖.如果该文件不存在,创建新文件.
			a	
				* 打开一个文件用于追加.如果该文件已存在,文件指针将会放在文件的结尾.也就是说,新的内容将会被写入到已有内容之后.如果该文件不存在,创建新文件进行写入.
			rb	
				* 以二进制格式打开一个文件用于只读.文件指针将会放在文件的开头.这是默认模式.
			wb	
				* 以二进制格式打开一个文件只用于写入.如果该文件已存在则将其覆盖.如果该文件不存在,创建新文件.
			ab	
				* 以二进制格式打开一个文件用于追加.如果该文件已存在,文件指针将会放在文件的结尾.也就是说,新的内容将会被写入到已有内容之后.如果该文件不存在,创建新文件进行写入.
			r+	
				* 打开一个文件用于读写.文件指针将会放在文件的开头.
			w+	
				* 打开一个文件用于读写.如果该文件已存在则将其覆盖.如果该文件不存在,创建新文件.
			a+	
				* 打开一个文件用于读写.如果该文件已存在,文件指针将会放在文件的结尾.文件打开时会是追加模式.如果该文件不存在,创建新文件用于读写.
			rb+	
				* 以二进制格式打开一个文件用于读写.文件指针将会放在文件的开头.
			wb+	
				* 以二进制格式打开一个文件用于读写.如果该文件已存在则将其覆盖.如果该文件不存在,创建新文件.
			ab+	
				* 以二进制格式打开一个文件用于追加.如果该文件已存在,文件指针将会放在文件的结尾.如果该文件不存在,创建新文件用于读写.

		* 关键字参数
			encoding
				* 指定以何种字符集打开该文件


----------------------------
Python-通用API				|
----------------------------


----------------------------
Python-TextIOWrapper		|
----------------------------
	* 文本文件对象,该对象就是所有的文本数据
	* 该对象可以被迭代
		path = "E:\\Main.java"
		file = open(path)
		for line in file:			
			print(line,end="")		#每一行的字符串
		
		for x,y in enumerate(file):
			print(x,y.rstrip())		#行号 & 每一行字符串

	* 属性
		str name
			* 文件名称
		
		str encoding
			* 文件的编码

		bool closed
			* 判断文件是否关闭

	* 方法
		str read()
			* 返回相对于当前指针,文件的所有文本数据
			* 第一个参数,表示要读取的字节个数,如果未指定,或者该参数为负数,则默认是所有
			* 读取到了文件末尾返回 None
			* '指针后移'

		bool readable()
			* 判断文件是否可读 

		str readline();
			* 从文件读取整行,包括 "\n" 字符
			* 如果指定了一个非负数的参数,则返回指定大小的字符数,包括 "\n" 字符,如果该值大于了当前行的字符数,仅仅返当前行
			* '指针后移'

		str[] readlines()
			* 从文件读取整行, "\n" 字符
			* 把读取到的每一行数据,作为字符串,存入[],读取到最后,返回[]
			* '指针后移'
			* 如果指定了非负的参数....
		
		readinto()
			* 不晓得干嘛的

		int fileno()
			* 返回文件描述符,每个文件的描述符,不同

		int write()
			* 写入字符数据,到缓冲区,返回写入的字符数量
			* 进行flush/close后才会刷出到磁盘
		
		bool writable()
			* 判断文件是否可写
		
		None writelines()
			* 写入一行数据
			* 参数是可以是str[],需要自己写入换行符

		None flush();
			* 刷出缓冲区,立即把数据写入到磁盘
			* 文件关闭后会自动刷新缓冲区,但有时需要在关闭前刷新它
		
		boolean isatty();
			* 如果文件连接到一个终端设备返回 True 否则返回 False
			* '打印机'

		None close()
			* 关闭资源
		
		int seek(offset,[type])
			* 设置文件指针
			* offset 决定了偏移量
			* type 可选的 int 形数据,给offset参数一个定义,表示要从哪个位置开始偏移
				0 代表从文件开头开始算起(默认)
				1 代表从当前位置开始算起
				2 代表从文件末尾算起
			* 返回 int,也就是偏移量
	
		bool seekable()
			* 判断文件是否可以移动指针
			* 'Linux中的设备文件,就无法进行移动,返回 False'

		int tell()
			* 返回指针的当前位置
			* '一个英文占1个字符,1个中文占3个字符,这种计算方式跟编码没有关系'
		
		truncate(n)
			* 从文件的首行首字符开始截断,截断文件为n个字符
			* 无n表示从'当前指针位置'起截断,截断之后,后面的所有字符被删除
			* 根据不同的打开模式,有不同的效果...尼玛,这个API好恶心
			* 返回 n,就是截取的字符数量
	
		detach()
			* ...在文件编辑过程中修改编码...好像是这个功能

----------------------------
Python-BufferedWriter		|
----------------------------
	* 二进制文件对象

